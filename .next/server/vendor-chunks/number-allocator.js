/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/number-allocator";
exports.ids = ["vendor-chunks/number-allocator"];
exports.modules = {

/***/ "(ssr)/./node_modules/number-allocator/index.js":
/*!************************************************!*\
  !*** ./node_modules/number-allocator/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\nconst NumberAllocator = __webpack_require__(/*! ./lib/number-allocator.js */ \"(ssr)/./node_modules/number-allocator/lib/number-allocator.js\")\n\nmodule.exports.NumberAllocator = NumberAllocator\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWFsbG9jYXRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsZ0dBQTJCOztBQUUzRCw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xkLXN0b3JhZ2Utc3lzdGVtLy4vbm9kZV9tb2R1bGVzL251bWJlci1hbGxvY2F0b3IvaW5kZXguanM/YmQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgVGFrYXRvc2hpIEtvbmRvIDIwMjFcbi8vXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcblxuY29uc3QgTnVtYmVyQWxsb2NhdG9yID0gcmVxdWlyZSgnLi9saWIvbnVtYmVyLWFsbG9jYXRvci5qcycpXG5cbm1vZHVsZS5leHBvcnRzLk51bWJlckFsbG9jYXRvciA9IE51bWJlckFsbG9jYXRvclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-allocator/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/number-allocator/lib/number-allocator.js":
/*!***************************************************************!*\
  !*** ./node_modules/number-allocator/lib/number-allocator.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n\n\nconst SortedSet = (__webpack_require__(/*! js-sdsl */ \"(ssr)/./node_modules/js-sdsl/dist/esm/index.js\").OrderedSet)\nconst debugTrace = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('number-allocator:trace')\nconst debugError = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.begin()\n  const low = it.pointer.low\n  const high = it.pointer.high\n  const num = low\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low\n    const high = it.pointer.high\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (low > num) return false\n\n    // |x----|\n    if (low === num) {\n      // x|----|\n      this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (high === num) {\n      // |----|x\n      this.ss.updateKeyByIterator(it, new Interval(low, high - 1))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |--x--|\n    // x|--|\n    this.ss.updateKeyByIterator(it, new Interval(num + 1, high))\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.upperBound(key)\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    it.pre()\n    const low = it.pointer.high\n    const high = it.pointer.high\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.updateKeyByIterator(it, new Interval(low, num))\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const high = it.pointer.high\n        this.ss.updateKeyByIterator(it, new Interval(num, high))\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low\n      const rHigh = it.pointer.high\n      it.pre()\n      const lLow = it.pointer.low\n      const lHigh = it.pointer.high\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it)\n          this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh))\n        } else {\n          // Concat to left\n          this.ss.updateKeyByIterator(it, new Interval(lLow, num))\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next())\n          this.ss.insert(new Interval(num, rHigh))\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbnVtYmVyLWFsbG9jYXRvci9saWIvbnVtYmVyLWFsbG9jYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosa0JBQWtCLGlHQUE2QjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBTztBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxzREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xkLXN0b3JhZ2Utc3lzdGVtLy4vbm9kZV9tb2R1bGVzL251bWJlci1hbGxvY2F0b3IvbGliL251bWJlci1hbGxvY2F0b3IuanM/MTRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgVGFrYXRvc2hpIEtvbmRvIDIwMjFcbi8vXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFNvcnRlZFNldCA9IHJlcXVpcmUoJ2pzLXNkc2wnKS5PcmRlcmVkU2V0XG5jb25zdCBkZWJ1Z1RyYWNlID0gcmVxdWlyZSgnZGVidWcnKSgnbnVtYmVyLWFsbG9jYXRvcjp0cmFjZScpXG5jb25zdCBkZWJ1Z0Vycm9yID0gcmVxdWlyZSgnZGVidWcnKSgnbnVtYmVyLWFsbG9jYXRvcjplcnJvcicpXG4vKipcbiAqIEludGVydmFsIGNvbnN0cnVjdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgIC0gVGhlIGxvd2VzdCB2YWx1ZSBvZiB0aGUgaW50ZXJ2YWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIC0gVGhlIGhpZ2hlc3QgdmFsdWUgb2YgdGhlIGludGVydmFsXG4gKi9cbmZ1bmN0aW9uIEludGVydmFsIChsb3csIGhpZ2gpIHtcbiAgdGhpcy5sb3cgPSBsb3dcbiAgdGhpcy5oaWdoID0gaGlnaFxufVxuXG5JbnRlcnZhbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmxvdyA9PT0gb3RoZXIubG93ICYmIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaFxufVxuXG5JbnRlcnZhbC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAodGhpcy5sb3cgPCBvdGhlci5sb3cgJiYgdGhpcy5oaWdoIDwgb3RoZXIubG93KSByZXR1cm4gLTFcbiAgaWYgKG90aGVyLmxvdyA8IHRoaXMubG93ICYmIG90aGVyLmhpZ2ggPCB0aGlzLmxvdykgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLyoqXG4gKiBOdW1iZXJBbGxvY2F0b3IgY29uc3RydWN0b3IuXG4gKiBUaGUgYWxsIG51bWJlcnMgYXJlIHNldCB0byB2YWNhbnQgc3RhdHVzLlxuICogVGltZSBDb21wbGV4aXR5IE8oMSlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiAgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYWxsb2NhdGFibGUuIFRoZSBudW1iZXIgbXVzdCBiZSBpbnRlZ2VyLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heGggLSBUaGUgbWluaW11bSBudW1iZXIgb2YgYWxsb2NhdGFibGUuIFRoZSBudW1iZXIgbXVzdCBiZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBOdW1iZXJBbGxvY2F0b3IgKG1pbiwgbWF4KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOdW1iZXJBbGxvY2F0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJBbGxvY2F0b3IobWluLCBtYXgpXG4gIH1cblxuICB0aGlzLm1pbiA9IG1pblxuICB0aGlzLm1heCA9IG1heFxuXG4gIHRoaXMuc3MgPSBuZXcgU29ydGVkU2V0KFxuICAgIFtdLFxuICAgIChsaHMsIHJocykgPT4ge1xuICAgICAgcmV0dXJuIGxocy5jb21wYXJlKHJocylcbiAgICB9XG4gIClcbiAgZGVidWdUcmFjZSgnQ3JlYXRlJylcbiAgdGhpcy5jbGVhcigpXG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCB2YWNhbnQgbnVtYmVyLiBUaGUgc3RhdHVzIG9mIHRoZSBudW1iZXIgaXMgbm90IHVwZGF0ZWQuXG4gKiBUaW1lIENvbXBsZXhpdHkgTygxKVxuICogQHJldHVybiB7TnVtYmVyfSAtIFRoZSBmaXJzdCB2YWNhbnQgbnVtYmVyLiBJZiBhbGwgbnVtYmVycyBhcmUgb2NjdXBpZWQsIHJldHVybiBudWxsLlxuICogICAgICAgICAgICAgICAgICAgIFdoZW4gYWxsb2MoKSBpcyBjYWxsZWQgdGhlbiB0aGUgc2FtZSB2YWx1ZSB3aWxsIGJlIGFsbG9jYXRlZC5cbiAqL1xuTnVtYmVyQWxsb2NhdG9yLnByb3RvdHlwZS5maXJzdFZhY2FudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3Muc2l6ZSgpID09PSAwKSByZXR1cm4gbnVsbFxuICByZXR1cm4gdGhpcy5zcy5mcm9udCgpLmxvd1xufVxuXG4vKipcbiAqIEFsbG9jYXRlIHRoZSBmaXJzdCB2YWNhbnQgbnVtYmVyLiBUaGUgbnVtYmVyIGJlY29tZSBvY2N1cGllZCBzdGF0dXMuXG4gKiBUaW1lIENvbXBsZXhpdHkgTygxKVxuICogQHJldHVybiB7TnVtYmVyfSAtIFRoZSBmaXJzdCB2YWNhbnQgbnVtYmVyLiBJZiBhbGwgbnVtYmVycyBhcmUgb2NjdXBpZWQsIHJldHVybiBudWxsLlxuICovXG5OdW1iZXJBbGxvY2F0b3IucHJvdG90eXBlLmFsbG9jID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zcy5zaXplKCkgPT09IDApIHtcbiAgICBkZWJ1Z1RyYWNlKCdhbGxvYygpOmVtcHR5JylcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IGl0ID0gdGhpcy5zcy5iZWdpbigpXG4gIGNvbnN0IGxvdyA9IGl0LnBvaW50ZXIubG93XG4gIGNvbnN0IGhpZ2ggPSBpdC5wb2ludGVyLmhpZ2hcbiAgY29uc3QgbnVtID0gbG93XG4gIGlmIChudW0gKyAxIDw9IGhpZ2gpIHtcbiAgICAvLyB4fC0tLS18XG4gICAgdGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKGl0LCBuZXcgSW50ZXJ2YWwobG93ICsgMSwgaGlnaCkpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zcy5lcmFzZUVsZW1lbnRCeVBvcygwKVxuICB9XG4gIGRlYnVnVHJhY2UoJ2FsbG9jKCk6JyArIG51bSlcbiAgcmV0dXJuIG51bVxufVxuXG4vKipcbiAqIFVzZSB0aGUgbnVtYmVyLiBUaGUgbnVtYmVyIGJlY29tZSBvY2N1cGllZCBzdGF0dXMuXG4gKiBJZiB0aGUgbnVtYmVyIGhhcyBhbHJlYWR5IGJlZW4gb2NjdXBpZWQsIHRoZW4gcmV0dXJuIGZhbHNlLlxuICogVGltZSBDb21wbGV4aXR5IE8obG9nTikgOiBOIGlzIHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzIChub3QgbnVtYmVycylcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gLSBUaGUgbnVtYmVyIHRvIHJlcXVlc3QgdXNlLlxuICogQHJldHVybiB7Qm9vbGVhbn0gLSBJZiBgbnVtYCB3YXMgbm90IG9jY3VwaWVkLCB0aGVuIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICovXG5OdW1iZXJBbGxvY2F0b3IucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgY29uc3Qga2V5ID0gbmV3IEludGVydmFsKG51bSwgbnVtKVxuICBjb25zdCBpdCA9IHRoaXMuc3MubG93ZXJCb3VuZChrZXkpXG4gIGlmICghaXQuZXF1YWxzKHRoaXMuc3MuZW5kKCkpKSB7XG4gICAgY29uc3QgbG93ID0gaXQucG9pbnRlci5sb3dcbiAgICBjb25zdCBoaWdoID0gaXQucG9pbnRlci5oaWdoXG4gICAgaWYgKGl0LnBvaW50ZXIuZXF1YWxzKGtleSkpIHtcbiAgICAgIC8vIHx4fFxuICAgICAgdGhpcy5zcy5lcmFzZUVsZW1lbnRCeUl0ZXJhdG9yKGl0KVxuICAgICAgZGVidWdUcmFjZSgndXNlKCk6JyArIG51bSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8geCB8LS0tLS18XG4gICAgaWYgKGxvdyA+IG51bSkgcmV0dXJuIGZhbHNlXG5cbiAgICAvLyB8eC0tLS18XG4gICAgaWYgKGxvdyA9PT0gbnVtKSB7XG4gICAgICAvLyB4fC0tLS18XG4gICAgICB0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IoaXQsIG5ldyBJbnRlcnZhbChsb3cgKyAxLCBoaWdoKSlcbiAgICAgIGRlYnVnVHJhY2UoJ3VzZSgpOicgKyBudW0pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHwtLS0teHxcbiAgICBpZiAoaGlnaCA9PT0gbnVtKSB7XG4gICAgICAvLyB8LS0tLXx4XG4gICAgICB0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IoaXQsIG5ldyBJbnRlcnZhbChsb3csIGhpZ2ggLSAxKSlcbiAgICAgIGRlYnVnVHJhY2UoJ3VzZSgpOicgKyBudW0pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHwtLXgtLXxcbiAgICAvLyB4fC0tfFxuICAgIHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihpdCwgbmV3IEludGVydmFsKG51bSArIDEsIGhpZ2gpKVxuICAgIC8vIHwtLXx4fC0tfFxuICAgIHRoaXMuc3MuaW5zZXJ0KG5ldyBJbnRlcnZhbChsb3csIG51bSAtIDEpKVxuICAgIGRlYnVnVHJhY2UoJ3VzZSgpOicgKyBudW0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlYnVnVHJhY2UoJ3VzZSgpOmZhaWxlZCcpXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIERlYWxsb2NhdGUgdGhlIG51bWJlci4gVGhlIG51bWJlciBiZWNvbWUgdmFjYW50IHN0YXR1cy5cbiAqIFRpbWUgQ29tcGxleGl0eSBPKGxvZ04pIDogTiBpcyB0aGUgbnVtYmVyIG9mIGludGVydmFscyAobm90IG51bWJlcnMpXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIC0gVGhlIG51bWJlciB0byBkZWFsbG9jYXRlLiBUaGUgbnVtYmVyIG11c3QgYmUgb2NjdXBpZWQgc3RhdHVzLlxuICogICAgICAgICAgICAgICAgICAgICAgIEluIG90aGVyIHdvcmRzLCB0aGUgbnVtYmVyIG11c3QgYmUgYWxsb2NhdGVkIGJ5IGFsbG9jKCkgb3Igb2NjdXBpZWQgYmUgdXNlKCkuXG4gKi9cbk51bWJlckFsbG9jYXRvci5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgaWYgKG51bSA8IHRoaXMubWluIHx8IG51bSA+IHRoaXMubWF4KSB7XG4gICAgZGVidWdFcnJvcignZnJlZSgpOicgKyBudW0gKyAnIGlzIG91dCBvZiByYW5nZScpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qga2V5ID0gbmV3IEludGVydmFsKG51bSwgbnVtKVxuICBjb25zdCBpdCA9IHRoaXMuc3MudXBwZXJCb3VuZChrZXkpXG4gIGlmIChpdC5lcXVhbHModGhpcy5zcy5lbmQoKSkpIHtcbiAgICAvLyAuLi4udlxuICAgIGlmIChpdC5lcXVhbHModGhpcy5zcy5iZWdpbigpKSkge1xuICAgICAgLy8gSW5zZXJ0IG5ldyBpbnRlcnZhbFxuICAgICAgdGhpcy5zcy5pbnNlcnQoa2V5KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGl0LnByZSgpXG4gICAgY29uc3QgbG93ID0gaXQucG9pbnRlci5oaWdoXG4gICAgY29uc3QgaGlnaCA9IGl0LnBvaW50ZXIuaGlnaFxuICAgIGlmIChoaWdoICsgMSA9PT0gbnVtKSB7XG4gICAgICAvLyBDb25jYXQgdG8gbGVmdFxuICAgICAgdGhpcy5zcy51cGRhdGVLZXlCeUl0ZXJhdG9yKGl0LCBuZXcgSW50ZXJ2YWwobG93LCBudW0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnQgbmV3IGludGVydmFsXG4gICAgICB0aGlzLnNzLmluc2VydChrZXkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpdC5lcXVhbHModGhpcy5zcy5iZWdpbigpKSkge1xuICAgICAgLy8gdi4uLi5cbiAgICAgIGlmIChudW0gKyAxID09PSBpdC5wb2ludGVyLmxvdykge1xuICAgICAgICAvLyBDb25jYXQgdG8gcmlnaHRcbiAgICAgICAgY29uc3QgaGlnaCA9IGl0LnBvaW50ZXIuaGlnaFxuICAgICAgICB0aGlzLnNzLnVwZGF0ZUtleUJ5SXRlcmF0b3IoaXQsIG5ldyBJbnRlcnZhbChudW0sIGhpZ2gpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5zZXJ0IG5ldyBpbnRlcnZhbFxuICAgICAgICB0aGlzLnNzLmluc2VydChrZXkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIC4udi4uXG4gICAgICBjb25zdCByTG93ID0gaXQucG9pbnRlci5sb3dcbiAgICAgIGNvbnN0IHJIaWdoID0gaXQucG9pbnRlci5oaWdoXG4gICAgICBpdC5wcmUoKVxuICAgICAgY29uc3QgbExvdyA9IGl0LnBvaW50ZXIubG93XG4gICAgICBjb25zdCBsSGlnaCA9IGl0LnBvaW50ZXIuaGlnaFxuICAgICAgaWYgKGxIaWdoICsgMSA9PT0gbnVtKSB7XG4gICAgICAgIGlmIChudW0gKyAxID09PSByTG93KSB7XG4gICAgICAgICAgLy8gQ29uY2F0IHRvIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgICAgdGhpcy5zcy5lcmFzZUVsZW1lbnRCeUl0ZXJhdG9yKGl0KVxuICAgICAgICAgIHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihpdCwgbmV3IEludGVydmFsKGxMb3csIHJIaWdoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb25jYXQgdG8gbGVmdFxuICAgICAgICAgIHRoaXMuc3MudXBkYXRlS2V5QnlJdGVyYXRvcihpdCwgbmV3IEludGVydmFsKGxMb3csIG51bSkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChudW0gKyAxID09PSByTG93KSB7XG4gICAgICAgICAgLy8gQ29uY2F0IHRvIHJpZ2h0XG4gICAgICAgICAgdGhpcy5zcy5lcmFzZUVsZW1lbnRCeUl0ZXJhdG9yKGl0Lm5leHQoKSlcbiAgICAgICAgICB0aGlzLnNzLmluc2VydChuZXcgSW50ZXJ2YWwobnVtLCBySGlnaCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW5zZXJ0IG5ldyBpbnRlcnZhbFxuICAgICAgICAgIHRoaXMuc3MuaW5zZXJ0KGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWJ1Z1RyYWNlKCdmcmVlKCk6JyArIG51bSlcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgb2NjdXBpZWQgbnVtYmVycy5cbiAqIFRoZSBhbGwgbnVtYmVycyBhcmUgc2V0IHRvIHZhY2FudCBzdGF0dXMuXG4gKiBUaW1lIENvbXBsZXhpdHkgTygxKVxuICovXG5OdW1iZXJBbGxvY2F0b3IucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Z1RyYWNlKCdjbGVhcigpJylcbiAgdGhpcy5zcy5jbGVhcigpXG4gIHRoaXMuc3MuaW5zZXJ0KG5ldyBJbnRlcnZhbCh0aGlzLm1pbiwgdGhpcy5tYXgpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGludGVydmFscy4gSW50ZXJ2YWwgaXMgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoaXMgbGlicmFyeS5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZy5cbiAqIFRpbWUgQ29tcGxleGl0eSBPKDEpXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIG51bWJlciBvZiBpbnRlcnZhbHMuXG4gKi9cbk51bWJlckFsbG9jYXRvci5wcm90b3R5cGUuaW50ZXJ2YWxDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3Muc2l6ZSgpXG59XG5cbi8qKlxuICogRHVtcCB0aGUgaW50ZXJuYWwgc3RydWN0b3Igb2YgdGhlIGxpYnJhcnkuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcuXG4gKiBUaW1lIENvbXBsZXhpdHkgTyhOKSA6IE4gaXMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgKG5vdCBudW1iZXJzKVxuICovXG5OdW1iZXJBbGxvY2F0b3IucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUubG9nKCdsZW5ndGg6JyArIHRoaXMuc3Muc2l6ZSgpKVxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5zcykge1xuICAgIGNvbnNvbGUubG9nKGVsZW1lbnQpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJBbGxvY2F0b3JcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/number-allocator/lib/number-allocator.js\n");

/***/ })

};
;