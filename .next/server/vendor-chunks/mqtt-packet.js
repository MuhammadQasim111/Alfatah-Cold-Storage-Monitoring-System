/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mqtt-packet";
exports.ids = ["vendor-chunks/mqtt-packet"];
exports.modules = {

/***/ "(ssr)/./node_modules/mqtt-packet/constants.js":
/*!***********************************************!*\
  !*** ./node_modules/mqtt-packet/constants.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Protocol - protocol constants */\nconst protocol = module.exports\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\n\n/* Command code => mnemonic */\nprotocol.types = {\n  0: 'reserved',\n  1: 'connect',\n  2: 'connack',\n  3: 'publish',\n  4: 'puback',\n  5: 'pubrec',\n  6: 'pubrel',\n  7: 'pubcomp',\n  8: 'subscribe',\n  9: 'suback',\n  10: 'unsubscribe',\n  11: 'unsuback',\n  12: 'pingreq',\n  13: 'pingresp',\n  14: 'disconnect',\n  15: 'auth'\n}\n\nprotocol.requiredHeaderFlags = {\n  1: 0, // 'connect'\n  2: 0, // 'connack'\n  4: 0, // 'puback'\n  5: 0, // 'pubrec'\n  6: 2, // 'pubrel'\n  7: 0, // 'pubcomp'\n  8: 2, // 'subscribe'\n  9: 0, // 'suback'\n  10: 2, // 'unsubscribe'\n  11: 0, // 'unsuback'\n  12: 0, // 'pingreq'\n  13: 0, // 'pingresp'\n  14: 0, // 'disconnect'\n  15: 0 // 'auth'\n}\n\nprotocol.requiredHeaderFlagsErrors = {}\nfor (const k in protocol.requiredHeaderFlags) {\n  const v = protocol.requiredHeaderFlags[k]\n  protocol.requiredHeaderFlagsErrors[k] = 'Invalid header flag bits, must be 0x' + v.toString(16) + ' for ' + protocol.types[k] + ' packet'\n}\n\n/* Mnemonic => Command code */\nprotocol.codes = {}\nfor (const k in protocol.types) {\n  const v = protocol.types[k]\n  protocol.codes[v] = k\n}\n\n/* Header */\nprotocol.CMD_SHIFT = 4\nprotocol.CMD_MASK = 0xF0\nprotocol.DUP_MASK = 0x08\nprotocol.QOS_MASK = 0x03\nprotocol.QOS_SHIFT = 1\nprotocol.RETAIN_MASK = 0x01\n\n/* Length */\nprotocol.VARBYTEINT_MASK = 0x7F\nprotocol.VARBYTEINT_FIN_MASK = 0x80\nprotocol.VARBYTEINT_MAX = 268435455\n\n/* Connack */\nprotocol.SESSIONPRESENT_MASK = 0x01\nprotocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])\nprotocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT])\n\n/* Connect */\nprotocol.USERNAME_MASK = 0x80\nprotocol.PASSWORD_MASK = 0x40\nprotocol.WILL_RETAIN_MASK = 0x20\nprotocol.WILL_QOS_MASK = 0x18\nprotocol.WILL_QOS_SHIFT = 3\nprotocol.WILL_FLAG_MASK = 0x04\nprotocol.CLEAN_SESSION_MASK = 0x02\nprotocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT])\n\n/* Properties */\nprotocol.properties = {\n  sessionExpiryInterval: 17,\n  willDelayInterval: 24,\n  receiveMaximum: 33,\n  maximumPacketSize: 39,\n  topicAliasMaximum: 34,\n  requestResponseInformation: 25,\n  requestProblemInformation: 23,\n  userProperties: 38,\n  authenticationMethod: 21,\n  authenticationData: 22,\n  payloadFormatIndicator: 1,\n  messageExpiryInterval: 2,\n  contentType: 3,\n  responseTopic: 8,\n  correlationData: 9,\n  maximumQoS: 36,\n  retainAvailable: 37,\n  assignedClientIdentifier: 18,\n  reasonString: 31,\n  wildcardSubscriptionAvailable: 40,\n  subscriptionIdentifiersAvailable: 41,\n  sharedSubscriptionAvailable: 42,\n  serverKeepAlive: 19,\n  responseInformation: 26,\n  serverReference: 28,\n  topicAlias: 35,\n  subscriptionIdentifier: 11\n}\nprotocol.propertiesCodes = {}\nfor (const prop in protocol.properties) {\n  const id = protocol.properties[prop]\n  protocol.propertiesCodes[id] = prop\n}\nprotocol.propertiesTypes = {\n  sessionExpiryInterval: 'int32',\n  willDelayInterval: 'int32',\n  receiveMaximum: 'int16',\n  maximumPacketSize: 'int32',\n  topicAliasMaximum: 'int16',\n  requestResponseInformation: 'byte',\n  requestProblemInformation: 'byte',\n  userProperties: 'pair',\n  authenticationMethod: 'string',\n  authenticationData: 'binary',\n  payloadFormatIndicator: 'byte',\n  messageExpiryInterval: 'int32',\n  contentType: 'string',\n  responseTopic: 'string',\n  correlationData: 'binary',\n  maximumQoS: 'int8',\n  retainAvailable: 'byte',\n  assignedClientIdentifier: 'string',\n  reasonString: 'string',\n  wildcardSubscriptionAvailable: 'byte',\n  subscriptionIdentifiersAvailable: 'byte',\n  sharedSubscriptionAvailable: 'byte',\n  serverKeepAlive: 'int16',\n  responseInformation: 'string',\n  serverReference: 'string',\n  topicAlias: 'int16',\n  subscriptionIdentifier: 'var'\n}\n\nfunction genHeader (type) {\n  return [0, 1, 2].map(qos => {\n    return [0, 1].map(dup => {\n      return [0, 1].map(retain => {\n        const buf = Buffer.alloc(1)\n        buf.writeUInt8(\n          protocol.codes[type] << protocol.CMD_SHIFT |\n          (dup ? protocol.DUP_MASK : 0) |\n          qos << protocol.QOS_SHIFT | retain, 0, true)\n        return buf\n      })\n    })\n  })\n}\n\n/* Publish */\nprotocol.PUBLISH_HEADER = genHeader('publish')\n\n/* Subscribe */\nprotocol.SUBSCRIBE_HEADER = genHeader('subscribe')\nprotocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03\nprotocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01\nprotocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2\nprotocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01\nprotocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3\nprotocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03\nprotocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4\nprotocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20]\nprotocol.SUBSCRIBE_OPTIONS_NL = 0x04\nprotocol.SUBSCRIBE_OPTIONS_RAP = 0x08\nprotocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02]\n\n/* Unsubscribe */\nprotocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')\n\n/* Confirmations */\nprotocol.ACKS = {\n  unsuback: genHeader('unsuback'),\n  puback: genHeader('puback'),\n  pubcomp: genHeader('pubcomp'),\n  pubrel: genHeader('pubrel'),\n  pubrec: genHeader('pubrec')\n}\n\nprotocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT])\n\n/* Protocol versions */\nprotocol.VERSION3 = Buffer.from([3])\nprotocol.VERSION4 = Buffer.from([4])\nprotocol.VERSION5 = Buffer.from([5])\nprotocol.VERSION131 = Buffer.from([131])\nprotocol.VERSION132 = Buffer.from([132])\n\n/* QoS */\nprotocol.QOS = [0, 1, 2].map(qos => {\n  return Buffer.from([qos])\n})\n\n/* Empty packets */\nprotocol.EMPTY = {\n  pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),\n  pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),\n  disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])\n}\n\nprotocol.MQTT5_PUBACK_PUBREC_CODES = {\n  0x00: 'Success',\n  0x10: 'No matching subscribers',\n  0x80: 'Unspecified error',\n  0x83: 'Implementation specific error',\n  0x87: 'Not authorized',\n  0x90: 'Topic Name invalid',\n  0x91: 'Packet identifier in use',\n  0x97: 'Quota exceeded',\n  0x99: 'Payload format invalid'\n}\n\nprotocol.MQTT5_PUBREL_PUBCOMP_CODES = {\n  0x00: 'Success',\n  0x92: 'Packet Identifier not found'\n}\n\nprotocol.MQTT5_SUBACK_CODES = {\n  0x00: 'Granted QoS 0',\n  0x01: 'Granted QoS 1',\n  0x02: 'Granted QoS 2',\n  0x80: 'Unspecified error',\n  0x83: 'Implementation specific error',\n  0x87: 'Not authorized',\n  0x8F: 'Topic Filter invalid',\n  0x91: 'Packet Identifier in use',\n  0x97: 'Quota exceeded',\n  0x9E: 'Shared Subscriptions not supported',\n  0xA1: 'Subscription Identifiers not supported',\n  0xA2: 'Wildcard Subscriptions not supported'\n}\n\nprotocol.MQTT5_UNSUBACK_CODES = {\n  0x00: 'Success',\n  0x11: 'No subscription existed',\n  0x80: 'Unspecified error',\n  0x83: 'Implementation specific error',\n  0x87: 'Not authorized',\n  0x8F: 'Topic Filter invalid',\n  0x91: 'Packet Identifier in use'\n}\n\nprotocol.MQTT5_DISCONNECT_CODES = {\n  0x00: 'Normal disconnection',\n  0x04: 'Disconnect with Will Message',\n  0x80: 'Unspecified error',\n  0x81: 'Malformed Packet',\n  0x82: 'Protocol Error',\n  0x83: 'Implementation specific error',\n  0x87: 'Not authorized',\n  0x89: 'Server busy',\n  0x8B: 'Server shutting down',\n  0x8D: 'Keep Alive timeout',\n  0x8E: 'Session taken over',\n  0x8F: 'Topic Filter invalid',\n  0x90: 'Topic Name invalid',\n  0x93: 'Receive Maximum exceeded',\n  0x94: 'Topic Alias invalid',\n  0x95: 'Packet too large',\n  0x96: 'Message rate too high',\n  0x97: 'Quota exceeded',\n  0x98: 'Administrative action',\n  0x99: 'Payload format invalid',\n  0x9A: 'Retain not supported',\n  0x9B: 'QoS not supported',\n  0x9C: 'Use another server',\n  0x9D: 'Server moved',\n  0x9E: 'Shared Subscriptions not supported',\n  0x9F: 'Connection rate exceeded',\n  0xA0: 'Maximum connect time',\n  0xA1: 'Subscription Identifiers not supported',\n  0xA2: 'Wildcard Subscriptions not supported'\n}\n\nprotocol.MQTT5_AUTH_CODES = {\n  0x00: 'Success',\n  0x18: 'Continue authentication',\n  0x19: 'Re-authenticate'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sZC1zdG9yYWdlLXN5c3RlbS8uL25vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC9jb25zdGFudHMuanM/MWM2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBQcm90b2NvbCAtIHByb3RvY29sIGNvbnN0YW50cyAqL1xuY29uc3QgcHJvdG9jb2wgPSBtb2R1bGUuZXhwb3J0c1xuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbi8qIENvbW1hbmQgY29kZSA9PiBtbmVtb25pYyAqL1xucHJvdG9jb2wudHlwZXMgPSB7XG4gIDA6ICdyZXNlcnZlZCcsXG4gIDE6ICdjb25uZWN0JyxcbiAgMjogJ2Nvbm5hY2snLFxuICAzOiAncHVibGlzaCcsXG4gIDQ6ICdwdWJhY2snLFxuICA1OiAncHVicmVjJyxcbiAgNjogJ3B1YnJlbCcsXG4gIDc6ICdwdWJjb21wJyxcbiAgODogJ3N1YnNjcmliZScsXG4gIDk6ICdzdWJhY2snLFxuICAxMDogJ3Vuc3Vic2NyaWJlJyxcbiAgMTE6ICd1bnN1YmFjaycsXG4gIDEyOiAncGluZ3JlcScsXG4gIDEzOiAncGluZ3Jlc3AnLFxuICAxNDogJ2Rpc2Nvbm5lY3QnLFxuICAxNTogJ2F1dGgnXG59XG5cbnByb3RvY29sLnJlcXVpcmVkSGVhZGVyRmxhZ3MgPSB7XG4gIDE6IDAsIC8vICdjb25uZWN0J1xuICAyOiAwLCAvLyAnY29ubmFjaydcbiAgNDogMCwgLy8gJ3B1YmFjaydcbiAgNTogMCwgLy8gJ3B1YnJlYydcbiAgNjogMiwgLy8gJ3B1YnJlbCdcbiAgNzogMCwgLy8gJ3B1YmNvbXAnXG4gIDg6IDIsIC8vICdzdWJzY3JpYmUnXG4gIDk6IDAsIC8vICdzdWJhY2snXG4gIDEwOiAyLCAvLyAndW5zdWJzY3JpYmUnXG4gIDExOiAwLCAvLyAndW5zdWJhY2snXG4gIDEyOiAwLCAvLyAncGluZ3JlcSdcbiAgMTM6IDAsIC8vICdwaW5ncmVzcCdcbiAgMTQ6IDAsIC8vICdkaXNjb25uZWN0J1xuICAxNTogMCAvLyAnYXV0aCdcbn1cblxucHJvdG9jb2wucmVxdWlyZWRIZWFkZXJGbGFnc0Vycm9ycyA9IHt9XG5mb3IgKGNvbnN0IGsgaW4gcHJvdG9jb2wucmVxdWlyZWRIZWFkZXJGbGFncykge1xuICBjb25zdCB2ID0gcHJvdG9jb2wucmVxdWlyZWRIZWFkZXJGbGFnc1trXVxuICBwcm90b2NvbC5yZXF1aXJlZEhlYWRlckZsYWdzRXJyb3JzW2tdID0gJ0ludmFsaWQgaGVhZGVyIGZsYWcgYml0cywgbXVzdCBiZSAweCcgKyB2LnRvU3RyaW5nKDE2KSArICcgZm9yICcgKyBwcm90b2NvbC50eXBlc1trXSArICcgcGFja2V0J1xufVxuXG4vKiBNbmVtb25pYyA9PiBDb21tYW5kIGNvZGUgKi9cbnByb3RvY29sLmNvZGVzID0ge31cbmZvciAoY29uc3QgayBpbiBwcm90b2NvbC50eXBlcykge1xuICBjb25zdCB2ID0gcHJvdG9jb2wudHlwZXNba11cbiAgcHJvdG9jb2wuY29kZXNbdl0gPSBrXG59XG5cbi8qIEhlYWRlciAqL1xucHJvdG9jb2wuQ01EX1NISUZUID0gNFxucHJvdG9jb2wuQ01EX01BU0sgPSAweEYwXG5wcm90b2NvbC5EVVBfTUFTSyA9IDB4MDhcbnByb3RvY29sLlFPU19NQVNLID0gMHgwM1xucHJvdG9jb2wuUU9TX1NISUZUID0gMVxucHJvdG9jb2wuUkVUQUlOX01BU0sgPSAweDAxXG5cbi8qIExlbmd0aCAqL1xucHJvdG9jb2wuVkFSQllURUlOVF9NQVNLID0gMHg3RlxucHJvdG9jb2wuVkFSQllURUlOVF9GSU5fTUFTSyA9IDB4ODBcbnByb3RvY29sLlZBUkJZVEVJTlRfTUFYID0gMjY4NDM1NDU1XG5cbi8qIENvbm5hY2sgKi9cbnByb3RvY29sLlNFU1NJT05QUkVTRU5UX01BU0sgPSAweDAxXG5wcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfTUFTS10pXG5wcm90b2NvbC5DT05OQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlcy5jb25uYWNrIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIENvbm5lY3QgKi9cbnByb3RvY29sLlVTRVJOQU1FX01BU0sgPSAweDgwXG5wcm90b2NvbC5QQVNTV09SRF9NQVNLID0gMHg0MFxucHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA9IDB4MjBcbnByb3RvY29sLldJTExfUU9TX01BU0sgPSAweDE4XG5wcm90b2NvbC5XSUxMX1FPU19TSElGVCA9IDNcbnByb3RvY29sLldJTExfRkxBR19NQVNLID0gMHgwNFxucHJvdG9jb2wuQ0xFQU5fU0VTU0lPTl9NQVNLID0gMHgwMlxucHJvdG9jb2wuQ09OTkVDVF9IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXMuY29ubmVjdCA8PCBwcm90b2NvbC5DTURfU0hJRlRdKVxuXG4vKiBQcm9wZXJ0aWVzICovXG5wcm90b2NvbC5wcm9wZXJ0aWVzID0ge1xuICBzZXNzaW9uRXhwaXJ5SW50ZXJ2YWw6IDE3LFxuICB3aWxsRGVsYXlJbnRlcnZhbDogMjQsXG4gIHJlY2VpdmVNYXhpbXVtOiAzMyxcbiAgbWF4aW11bVBhY2tldFNpemU6IDM5LFxuICB0b3BpY0FsaWFzTWF4aW11bTogMzQsXG4gIHJlcXVlc3RSZXNwb25zZUluZm9ybWF0aW9uOiAyNSxcbiAgcmVxdWVzdFByb2JsZW1JbmZvcm1hdGlvbjogMjMsXG4gIHVzZXJQcm9wZXJ0aWVzOiAzOCxcbiAgYXV0aGVudGljYXRpb25NZXRob2Q6IDIxLFxuICBhdXRoZW50aWNhdGlvbkRhdGE6IDIyLFxuICBwYXlsb2FkRm9ybWF0SW5kaWNhdG9yOiAxLFxuICBtZXNzYWdlRXhwaXJ5SW50ZXJ2YWw6IDIsXG4gIGNvbnRlbnRUeXBlOiAzLFxuICByZXNwb25zZVRvcGljOiA4LFxuICBjb3JyZWxhdGlvbkRhdGE6IDksXG4gIG1heGltdW1Rb1M6IDM2LFxuICByZXRhaW5BdmFpbGFibGU6IDM3LFxuICBhc3NpZ25lZENsaWVudElkZW50aWZpZXI6IDE4LFxuICByZWFzb25TdHJpbmc6IDMxLFxuICB3aWxkY2FyZFN1YnNjcmlwdGlvbkF2YWlsYWJsZTogNDAsXG4gIHN1YnNjcmlwdGlvbklkZW50aWZpZXJzQXZhaWxhYmxlOiA0MSxcbiAgc2hhcmVkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOiA0MixcbiAgc2VydmVyS2VlcEFsaXZlOiAxOSxcbiAgcmVzcG9uc2VJbmZvcm1hdGlvbjogMjYsXG4gIHNlcnZlclJlZmVyZW5jZTogMjgsXG4gIHRvcGljQWxpYXM6IDM1LFxuICBzdWJzY3JpcHRpb25JZGVudGlmaWVyOiAxMVxufVxucHJvdG9jb2wucHJvcGVydGllc0NvZGVzID0ge31cbmZvciAoY29uc3QgcHJvcCBpbiBwcm90b2NvbC5wcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IGlkID0gcHJvdG9jb2wucHJvcGVydGllc1twcm9wXVxuICBwcm90b2NvbC5wcm9wZXJ0aWVzQ29kZXNbaWRdID0gcHJvcFxufVxucHJvdG9jb2wucHJvcGVydGllc1R5cGVzID0ge1xuICBzZXNzaW9uRXhwaXJ5SW50ZXJ2YWw6ICdpbnQzMicsXG4gIHdpbGxEZWxheUludGVydmFsOiAnaW50MzInLFxuICByZWNlaXZlTWF4aW11bTogJ2ludDE2JyxcbiAgbWF4aW11bVBhY2tldFNpemU6ICdpbnQzMicsXG4gIHRvcGljQWxpYXNNYXhpbXVtOiAnaW50MTYnLFxuICByZXF1ZXN0UmVzcG9uc2VJbmZvcm1hdGlvbjogJ2J5dGUnLFxuICByZXF1ZXN0UHJvYmxlbUluZm9ybWF0aW9uOiAnYnl0ZScsXG4gIHVzZXJQcm9wZXJ0aWVzOiAncGFpcicsXG4gIGF1dGhlbnRpY2F0aW9uTWV0aG9kOiAnc3RyaW5nJyxcbiAgYXV0aGVudGljYXRpb25EYXRhOiAnYmluYXJ5JyxcbiAgcGF5bG9hZEZvcm1hdEluZGljYXRvcjogJ2J5dGUnLFxuICBtZXNzYWdlRXhwaXJ5SW50ZXJ2YWw6ICdpbnQzMicsXG4gIGNvbnRlbnRUeXBlOiAnc3RyaW5nJyxcbiAgcmVzcG9uc2VUb3BpYzogJ3N0cmluZycsXG4gIGNvcnJlbGF0aW9uRGF0YTogJ2JpbmFyeScsXG4gIG1heGltdW1Rb1M6ICdpbnQ4JyxcbiAgcmV0YWluQXZhaWxhYmxlOiAnYnl0ZScsXG4gIGFzc2lnbmVkQ2xpZW50SWRlbnRpZmllcjogJ3N0cmluZycsXG4gIHJlYXNvblN0cmluZzogJ3N0cmluZycsXG4gIHdpbGRjYXJkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOiAnYnl0ZScsXG4gIHN1YnNjcmlwdGlvbklkZW50aWZpZXJzQXZhaWxhYmxlOiAnYnl0ZScsXG4gIHNoYXJlZFN1YnNjcmlwdGlvbkF2YWlsYWJsZTogJ2J5dGUnLFxuICBzZXJ2ZXJLZWVwQWxpdmU6ICdpbnQxNicsXG4gIHJlc3BvbnNlSW5mb3JtYXRpb246ICdzdHJpbmcnLFxuICBzZXJ2ZXJSZWZlcmVuY2U6ICdzdHJpbmcnLFxuICB0b3BpY0FsaWFzOiAnaW50MTYnLFxuICBzdWJzY3JpcHRpb25JZGVudGlmaWVyOiAndmFyJ1xufVxuXG5mdW5jdGlvbiBnZW5IZWFkZXIgKHR5cGUpIHtcbiAgcmV0dXJuIFswLCAxLCAyXS5tYXAocW9zID0+IHtcbiAgICByZXR1cm4gWzAsIDFdLm1hcChkdXAgPT4ge1xuICAgICAgcmV0dXJuIFswLCAxXS5tYXAocmV0YWluID0+IHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDEpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KFxuICAgICAgICAgIHByb3RvY29sLmNvZGVzW3R5cGVdIDw8IHByb3RvY29sLkNNRF9TSElGVCB8XG4gICAgICAgICAgKGR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMCkgfFxuICAgICAgICAgIHFvcyA8PCBwcm90b2NvbC5RT1NfU0hJRlQgfCByZXRhaW4sIDAsIHRydWUpXG4gICAgICAgIHJldHVybiBidWZcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLyogUHVibGlzaCAqL1xucHJvdG9jb2wuUFVCTElTSF9IRUFERVIgPSBnZW5IZWFkZXIoJ3B1Ymxpc2gnKVxuXG4vKiBTdWJzY3JpYmUgKi9cbnByb3RvY29sLlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3N1YnNjcmliZScpXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19RT1NfTUFTSyA9IDB4MDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MX01BU0sgPSAweDAxXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCA9IDJcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JBUF9NQVNLID0gMHgwMVxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUID0gM1xucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkhfTUFTSyA9IDB4MDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JIX1NISUZUID0gNFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkggPSBbMHgwMCwgMHgxMCwgMHgyMF1cbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MID0gMHgwNFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQID0gMHgwOFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUU9TID0gWzB4MDAsIDB4MDEsIDB4MDJdXG5cbi8qIFVuc3Vic2NyaWJlICovXG5wcm90b2NvbC5VTlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3Vuc3Vic2NyaWJlJylcblxuLyogQ29uZmlybWF0aW9ucyAqL1xucHJvdG9jb2wuQUNLUyA9IHtcbiAgdW5zdWJhY2s6IGdlbkhlYWRlcigndW5zdWJhY2snKSxcbiAgcHViYWNrOiBnZW5IZWFkZXIoJ3B1YmFjaycpLFxuICBwdWJjb21wOiBnZW5IZWFkZXIoJ3B1YmNvbXAnKSxcbiAgcHVicmVsOiBnZW5IZWFkZXIoJ3B1YnJlbCcpLFxuICBwdWJyZWM6IGdlbkhlYWRlcigncHVicmVjJylcbn1cblxucHJvdG9jb2wuU1VCQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlcy5zdWJhY2sgPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogUHJvdG9jb2wgdmVyc2lvbnMgKi9cbnByb3RvY29sLlZFUlNJT04zID0gQnVmZmVyLmZyb20oWzNdKVxucHJvdG9jb2wuVkVSU0lPTjQgPSBCdWZmZXIuZnJvbShbNF0pXG5wcm90b2NvbC5WRVJTSU9ONSA9IEJ1ZmZlci5mcm9tKFs1XSlcbnByb3RvY29sLlZFUlNJT04xMzEgPSBCdWZmZXIuZnJvbShbMTMxXSlcbnByb3RvY29sLlZFUlNJT04xMzIgPSBCdWZmZXIuZnJvbShbMTMyXSlcblxuLyogUW9TICovXG5wcm90b2NvbC5RT1MgPSBbMCwgMSwgMl0ubWFwKHFvcyA9PiB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShbcW9zXSlcbn0pXG5cbi8qIEVtcHR5IHBhY2tldHMgKi9cbnByb3RvY29sLkVNUFRZID0ge1xuICBwaW5ncmVxOiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXMucGluZ3JlcSA8PCA0LCAwXSksXG4gIHBpbmdyZXNwOiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXMucGluZ3Jlc3AgPDwgNCwgMF0pLFxuICBkaXNjb25uZWN0OiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXMuZGlzY29ubmVjdCA8PCA0LCAwXSlcbn1cblxucHJvdG9jb2wuTVFUVDVfUFVCQUNLX1BVQlJFQ19DT0RFUyA9IHtcbiAgMHgwMDogJ1N1Y2Nlc3MnLFxuICAweDEwOiAnTm8gbWF0Y2hpbmcgc3Vic2NyaWJlcnMnLFxuICAweDgwOiAnVW5zcGVjaWZpZWQgZXJyb3InLFxuICAweDgzOiAnSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgZXJyb3InLFxuICAweDg3OiAnTm90IGF1dGhvcml6ZWQnLFxuICAweDkwOiAnVG9waWMgTmFtZSBpbnZhbGlkJyxcbiAgMHg5MTogJ1BhY2tldCBpZGVudGlmaWVyIGluIHVzZScsXG4gIDB4OTc6ICdRdW90YSBleGNlZWRlZCcsXG4gIDB4OTk6ICdQYXlsb2FkIGZvcm1hdCBpbnZhbGlkJ1xufVxuXG5wcm90b2NvbC5NUVRUNV9QVUJSRUxfUFVCQ09NUF9DT0RFUyA9IHtcbiAgMHgwMDogJ1N1Y2Nlc3MnLFxuICAweDkyOiAnUGFja2V0IElkZW50aWZpZXIgbm90IGZvdW5kJ1xufVxuXG5wcm90b2NvbC5NUVRUNV9TVUJBQ0tfQ09ERVMgPSB7XG4gIDB4MDA6ICdHcmFudGVkIFFvUyAwJyxcbiAgMHgwMTogJ0dyYW50ZWQgUW9TIDEnLFxuICAweDAyOiAnR3JhbnRlZCBRb1MgMicsXG4gIDB4ODA6ICdVbnNwZWNpZmllZCBlcnJvcicsXG4gIDB4ODM6ICdJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBlcnJvcicsXG4gIDB4ODc6ICdOb3QgYXV0aG9yaXplZCcsXG4gIDB4OEY6ICdUb3BpYyBGaWx0ZXIgaW52YWxpZCcsXG4gIDB4OTE6ICdQYWNrZXQgSWRlbnRpZmllciBpbiB1c2UnLFxuICAweDk3OiAnUXVvdGEgZXhjZWVkZWQnLFxuICAweDlFOiAnU2hhcmVkIFN1YnNjcmlwdGlvbnMgbm90IHN1cHBvcnRlZCcsXG4gIDB4QTE6ICdTdWJzY3JpcHRpb24gSWRlbnRpZmllcnMgbm90IHN1cHBvcnRlZCcsXG4gIDB4QTI6ICdXaWxkY2FyZCBTdWJzY3JpcHRpb25zIG5vdCBzdXBwb3J0ZWQnXG59XG5cbnByb3RvY29sLk1RVFQ1X1VOU1VCQUNLX0NPREVTID0ge1xuICAweDAwOiAnU3VjY2VzcycsXG4gIDB4MTE6ICdObyBzdWJzY3JpcHRpb24gZXhpc3RlZCcsXG4gIDB4ODA6ICdVbnNwZWNpZmllZCBlcnJvcicsXG4gIDB4ODM6ICdJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBlcnJvcicsXG4gIDB4ODc6ICdOb3QgYXV0aG9yaXplZCcsXG4gIDB4OEY6ICdUb3BpYyBGaWx0ZXIgaW52YWxpZCcsXG4gIDB4OTE6ICdQYWNrZXQgSWRlbnRpZmllciBpbiB1c2UnXG59XG5cbnByb3RvY29sLk1RVFQ1X0RJU0NPTk5FQ1RfQ09ERVMgPSB7XG4gIDB4MDA6ICdOb3JtYWwgZGlzY29ubmVjdGlvbicsXG4gIDB4MDQ6ICdEaXNjb25uZWN0IHdpdGggV2lsbCBNZXNzYWdlJyxcbiAgMHg4MDogJ1Vuc3BlY2lmaWVkIGVycm9yJyxcbiAgMHg4MTogJ01hbGZvcm1lZCBQYWNrZXQnLFxuICAweDgyOiAnUHJvdG9jb2wgRXJyb3InLFxuICAweDgzOiAnSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgZXJyb3InLFxuICAweDg3OiAnTm90IGF1dGhvcml6ZWQnLFxuICAweDg5OiAnU2VydmVyIGJ1c3knLFxuICAweDhCOiAnU2VydmVyIHNodXR0aW5nIGRvd24nLFxuICAweDhEOiAnS2VlcCBBbGl2ZSB0aW1lb3V0JyxcbiAgMHg4RTogJ1Nlc3Npb24gdGFrZW4gb3ZlcicsXG4gIDB4OEY6ICdUb3BpYyBGaWx0ZXIgaW52YWxpZCcsXG4gIDB4OTA6ICdUb3BpYyBOYW1lIGludmFsaWQnLFxuICAweDkzOiAnUmVjZWl2ZSBNYXhpbXVtIGV4Y2VlZGVkJyxcbiAgMHg5NDogJ1RvcGljIEFsaWFzIGludmFsaWQnLFxuICAweDk1OiAnUGFja2V0IHRvbyBsYXJnZScsXG4gIDB4OTY6ICdNZXNzYWdlIHJhdGUgdG9vIGhpZ2gnLFxuICAweDk3OiAnUXVvdGEgZXhjZWVkZWQnLFxuICAweDk4OiAnQWRtaW5pc3RyYXRpdmUgYWN0aW9uJyxcbiAgMHg5OTogJ1BheWxvYWQgZm9ybWF0IGludmFsaWQnLFxuICAweDlBOiAnUmV0YWluIG5vdCBzdXBwb3J0ZWQnLFxuICAweDlCOiAnUW9TIG5vdCBzdXBwb3J0ZWQnLFxuICAweDlDOiAnVXNlIGFub3RoZXIgc2VydmVyJyxcbiAgMHg5RDogJ1NlcnZlciBtb3ZlZCcsXG4gIDB4OUU6ICdTaGFyZWQgU3Vic2NyaXB0aW9ucyBub3Qgc3VwcG9ydGVkJyxcbiAgMHg5RjogJ0Nvbm5lY3Rpb24gcmF0ZSBleGNlZWRlZCcsXG4gIDB4QTA6ICdNYXhpbXVtIGNvbm5lY3QgdGltZScsXG4gIDB4QTE6ICdTdWJzY3JpcHRpb24gSWRlbnRpZmllcnMgbm90IHN1cHBvcnRlZCcsXG4gIDB4QTI6ICdXaWxkY2FyZCBTdWJzY3JpcHRpb25zIG5vdCBzdXBwb3J0ZWQnXG59XG5cbnByb3RvY29sLk1RVFQ1X0FVVEhfQ09ERVMgPSB7XG4gIDB4MDA6ICdTdWNjZXNzJyxcbiAgMHgxODogJ0NvbnRpbnVlIGF1dGhlbnRpY2F0aW9uJyxcbiAgMHgxOTogJ1JlLWF1dGhlbnRpY2F0ZSdcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mqtt-packet/generate.js":
/*!**********************************************!*\
  !*** ./node_modules/mqtt-packet/generate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const writeToStream = __webpack_require__(/*! ./writeToStream */ \"(ssr)/./node_modules/mqtt-packet/writeToStream.js\")\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\n\nfunction generate (packet, opts) {\n  const stream = new Accumulator()\n  writeToStream(packet, stream, opts)\n  return stream.concat()\n}\n\nclass Accumulator extends EventEmitter {\n  constructor () {\n    super()\n    this._array = new Array(20)\n    this._i = 0\n  }\n\n  write (chunk) {\n    this._array[this._i++] = chunk\n    return true\n  }\n\n  concat () {\n    let length = 0\n    const lengths = new Array(this._array.length)\n    const list = this._array\n    let pos = 0\n    let i\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') lengths[i] = list[i].length\n      else lengths[i] = Buffer.byteLength(list[i])\n\n      length += lengths[i]\n    }\n\n    const result = Buffer.allocUnsafe(length)\n\n    for (i = 0; i < list.length && list[i] !== undefined; i++) {\n      if (typeof list[i] !== 'string') {\n        list[i].copy(result, pos)\n        pos += lengths[i]\n      } else {\n        result.write(list[i], pos)\n        pos += lengths[i]\n      }\n    }\n\n    return result\n  }\n\n  destroy (err) {\n    if (err) this.emit('error', err)\n  }\n}\n\nmodule.exports = generate\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvZ2VuZXJhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsMEVBQWlCO0FBQy9DLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDekMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xkLXN0b3JhZ2Utc3lzdGVtLy4vbm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L2dlbmVyYXRlLmpzPzNhYjIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgd3JpdGVUb1N0cmVhbSA9IHJlcXVpcmUoJy4vd3JpdGVUb1N0cmVhbScpXG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0LCBvcHRzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBBY2N1bXVsYXRvcigpXG4gIHdyaXRlVG9TdHJlYW0ocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gIHJldHVybiBzdHJlYW0uY29uY2F0KClcbn1cblxuY2xhc3MgQWNjdW11bGF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2FycmF5ID0gbmV3IEFycmF5KDIwKVxuICAgIHRoaXMuX2kgPSAwXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICB0aGlzLl9hcnJheVt0aGlzLl9pKytdID0gY2h1bmtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uY2F0ICgpIHtcbiAgICBsZXQgbGVuZ3RoID0gMFxuICAgIGNvbnN0IGxlbmd0aHMgPSBuZXcgQXJyYXkodGhpcy5fYXJyYXkubGVuZ3RoKVxuICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9hcnJheVxuICAgIGxldCBwb3MgPSAwXG4gICAgbGV0IGlcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0W2ldICE9PSAnc3RyaW5nJykgbGVuZ3Roc1tpXSA9IGxpc3RbaV0ubGVuZ3RoXG4gICAgICBlbHNlIGxlbmd0aHNbaV0gPSBCdWZmZXIuYnl0ZUxlbmd0aChsaXN0W2ldKVxuXG4gICAgICBsZW5ndGggKz0gbGVuZ3Roc1tpXVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGggJiYgbGlzdFtpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGlzdFtpXS5jb3B5KHJlc3VsdCwgcG9zKVxuICAgICAgICBwb3MgKz0gbGVuZ3Roc1tpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LndyaXRlKGxpc3RbaV0sIHBvcylcbiAgICAgICAgcG9zICs9IGxlbmd0aHNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/generate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mqtt-packet/mqtt.js":
/*!******************************************!*\
  !*** ./node_modules/mqtt-packet/mqtt.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.parser = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/mqtt-packet/parser.js\").parser\nexports.generate = __webpack_require__(/*! ./generate */ \"(ssr)/./node_modules/mqtt-packet/generate.js\")\nexports.writeToStream = __webpack_require__(/*! ./writeToStream */ \"(ssr)/./node_modules/mqtt-packet/writeToStream.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvbXF0dC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5R0FBMkM7QUFDM0Msd0dBQXdDO0FBQ3hDLHVIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGQtc3RvcmFnZS1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvbXF0dC5qcz9iYTc3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKS5wYXJzZXJcbmV4cG9ydHMuZ2VuZXJhdGUgPSByZXF1aXJlKCcuL2dlbmVyYXRlJylcbmV4cG9ydHMud3JpdGVUb1N0cmVhbSA9IHJlcXVpcmUoJy4vd3JpdGVUb1N0cmVhbScpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/mqtt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mqtt-packet/numbers.js":
/*!*********************************************!*\
  !*** ./node_modules/mqtt-packet/numbers.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst max = 65536\nconst cache = {}\n\n// in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer\n// later versions return a Buffer\n// alternative is Buffer.slice but that creates a new buffer\n// creating new buffers takes time\n// SubOk is only false on node < 8\nconst SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1))\n\nfunction generateBuffer (i) {\n  const buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (let i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\nfunction genBufVariableByteInt (num) {\n  const maxLength = 4 // max 4 bytes\n  let digit = 0\n  let pos = 0\n  const buffer = Buffer.allocUnsafe(maxLength)\n\n  do {\n    digit = num % 128 | 0\n    num = num / 128 | 0\n    if (num > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (num > 0 && pos < maxLength)\n\n  if (num > 0) {\n    pos = 0\n  }\n\n  return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos)\n}\n\nfunction generate4ByteBuffer (num) {\n  const buffer = Buffer.allocUnsafe(4)\n  buffer.writeUInt32BE(num, 0)\n  return buffer\n}\n\nmodule.exports = {\n  cache,\n  generateCache,\n  generateNumber: generateBuffer,\n  genBufVariableByteInt,\n  generate4ByteBuffer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGQtc3RvcmFnZS1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvbnVtYmVycy5qcz8wZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgbWF4ID0gNjU1MzZcbmNvbnN0IGNhY2hlID0ge31cblxuLy8gaW4gbm9kZSA2IEJ1ZmZlci5zdWJhcnJheSByZXR1cm5zIGEgVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgQnVmZmVyXG4vLyBsYXRlciB2ZXJzaW9ucyByZXR1cm4gYSBCdWZmZXJcbi8vIGFsdGVybmF0aXZlIGlzIEJ1ZmZlci5zbGljZSBidXQgdGhhdCBjcmVhdGVzIGEgbmV3IGJ1ZmZlclxuLy8gY3JlYXRpbmcgbmV3IGJ1ZmZlcnMgdGFrZXMgdGltZVxuLy8gU3ViT2sgaXMgb25seSBmYWxzZSBvbiBub2RlIDwgOFxuY29uc3QgU3ViT2sgPSBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLmZyb20oWzEsIDJdKS5zdWJhcnJheSgwLCAxKSlcblxuZnVuY3Rpb24gZ2VuZXJhdGVCdWZmZXIgKGkpIHtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGkgPj4gOCwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaSAmIDB4MDBGRiwgMCArIDEpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNhY2hlICgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGNhY2hlW2ldID0gZ2VuZXJhdGVCdWZmZXIoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQgKG51bSkge1xuICBjb25zdCBtYXhMZW5ndGggPSA0IC8vIG1heCA0IGJ5dGVzXG4gIGxldCBkaWdpdCA9IDBcbiAgbGV0IHBvcyA9IDBcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1heExlbmd0aClcblxuICBkbyB7XG4gICAgZGlnaXQgPSBudW0gJSAxMjggfCAwXG4gICAgbnVtID0gbnVtIC8gMTI4IHwgMFxuICAgIGlmIChudW0gPiAwKSBkaWdpdCA9IGRpZ2l0IHwgMHg4MFxuXG4gICAgYnVmZmVyLndyaXRlVUludDgoZGlnaXQsIHBvcysrKVxuICB9IHdoaWxlIChudW0gPiAwICYmIHBvcyA8IG1heExlbmd0aClcblxuICBpZiAobnVtID4gMCkge1xuICAgIHBvcyA9IDBcbiAgfVxuXG4gIHJldHVybiBTdWJPayA/IGJ1ZmZlci5zdWJhcnJheSgwLCBwb3MpIDogYnVmZmVyLnNsaWNlKDAsIHBvcylcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciAobnVtKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBidWZmZXIud3JpdGVVSW50MzJCRShudW0sIDApXG4gIHJldHVybiBidWZmZXJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhY2hlLFxuICBnZW5lcmF0ZUNhY2hlLFxuICBnZW5lcmF0ZU51bWJlcjogZ2VuZXJhdGVCdWZmZXIsXG4gIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCxcbiAgZ2VuZXJhdGU0Qnl0ZUJ1ZmZlclxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/numbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mqtt-packet/packet.js":
/*!********************************************!*\
  !*** ./node_modules/mqtt-packet/packet.js ***!
  \********************************************/
/***/ ((module) => {

eval("class Packet {\n  constructor () {\n    this.cmd = null\n    this.retain = false\n    this.qos = 0\n    this.dup = false\n    this.length = -1\n    this.topic = null\n    this.payload = null\n  }\n}\n\nmodule.exports = Packet\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvcGFja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xkLXN0b3JhZ2Utc3lzdGVtLy4vbm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L3BhY2tldC5qcz85ZjFkIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFBhY2tldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNtZCA9IG51bGxcbiAgICB0aGlzLnJldGFpbiA9IGZhbHNlXG4gICAgdGhpcy5xb3MgPSAwXG4gICAgdGhpcy5kdXAgPSBmYWxzZVxuICAgIHRoaXMubGVuZ3RoID0gLTFcbiAgICB0aGlzLnRvcGljID0gbnVsbFxuICAgIHRoaXMucGF5bG9hZCA9IG51bGxcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tldFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/packet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mqtt-packet/parser.js":
/*!********************************************!*\
  !*** ./node_modules/mqtt-packet/parser.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const bl = __webpack_require__(/*! bl */ \"(ssr)/./node_modules/bl/bl.js\")\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\")\nconst Packet = __webpack_require__(/*! ./packet */ \"(ssr)/./node_modules/mqtt-packet/packet.js\")\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/mqtt-packet/constants.js\")\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mqtt-packet:parser')\n\nclass Parser extends EventEmitter {\n  constructor () {\n    super()\n    this.parser = this.constructor.parser\n  }\n\n  static parser (opt) {\n    if (!(this instanceof Parser)) return (new Parser()).parser(opt)\n\n    this.settings = opt || {}\n\n    this._states = [\n      '_parseHeader',\n      '_parseLength',\n      '_parsePayload',\n      '_newPacket'\n    ]\n\n    this._resetState()\n    return this\n  }\n\n  _resetState () {\n    debug('_resetState: resetting packet, error, _list, and _stateCounter')\n    this.packet = new Packet()\n    this.error = null\n    this._list = bl()\n    this._stateCounter = 0\n  }\n\n  parse (buf) {\n    if (this.error) this._resetState()\n\n    this._list.append(buf)\n    debug('parse: current state: %s', this._states[this._stateCounter])\n    while ((this.packet.length !== -1 || this._list.length > 0) &&\n      this[this._states[this._stateCounter]]() &&\n      !this.error) {\n      this._stateCounter++\n      debug('parse: state complete. _stateCounter is now: %d', this._stateCounter)\n      debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length)\n      if (this._stateCounter >= this._states.length) this._stateCounter = 0\n    }\n    debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length)\n    return this._list.length\n  }\n\n  _parseHeader () {\n    // There is at least one byte in the buffer\n    const zero = this._list.readUInt8(0)\n    const cmdIndex = zero >> constants.CMD_SHIFT\n    this.packet.cmd = constants.types[cmdIndex]\n    const headerFlags = zero & 0xf\n    const requiredHeaderFlags = constants.requiredHeaderFlags[cmdIndex]\n    if (requiredHeaderFlags != null && headerFlags !== requiredHeaderFlags) {\n      // Where a flag bit is marked as “Reserved” in Table 2.2 - Flag Bits, it is reserved for future use and MUST be set to the value listed in that table [MQTT-2.2.2-1]. If invalid flags are received, the receiver MUST close the Network Connection [MQTT-2.2.2-2]\n      return this._emitError(new Error(constants.requiredHeaderFlagsErrors[cmdIndex]))\n    }\n    this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n    this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n    if (this.packet.qos > 2) {\n      return this._emitError(new Error('Packet must not have both QoS bits set to 1'))\n    }\n    this.packet.dup = (zero & constants.DUP_MASK) !== 0\n    debug('_parseHeader: packet: %o', this.packet)\n\n    this._list.consume(1)\n\n    return true\n  }\n\n  _parseLength () {\n    // There is at least one byte in the list\n    const result = this._parseVarByteNum(true)\n\n    if (result) {\n      this.packet.length = result.value\n      this._list.consume(result.bytes)\n    }\n    debug('_parseLength %d', result.value)\n    return !!result\n  }\n\n  _parsePayload () {\n    debug('_parsePayload: payload %O', this._list)\n    let result = false\n\n    // Do we have a payload? Do we have enough data to complete the payload?\n    // PINGs have no payload\n    if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n      this._pos = 0\n\n      switch (this.packet.cmd) {\n        case 'connect':\n          this._parseConnect()\n          break\n        case 'connack':\n          this._parseConnack()\n          break\n        case 'publish':\n          this._parsePublish()\n          break\n        case 'puback':\n        case 'pubrec':\n        case 'pubrel':\n        case 'pubcomp':\n          this._parseConfirmation()\n          break\n        case 'subscribe':\n          this._parseSubscribe()\n          break\n        case 'suback':\n          this._parseSuback()\n          break\n        case 'unsubscribe':\n          this._parseUnsubscribe()\n          break\n        case 'unsuback':\n          this._parseUnsuback()\n          break\n        case 'pingreq':\n        case 'pingresp':\n          // These are empty, nothing to do\n          break\n        case 'disconnect':\n          this._parseDisconnect()\n          break\n        case 'auth':\n          this._parseAuth()\n          break\n        default:\n          this._emitError(new Error('Not supported'))\n      }\n\n      result = true\n    }\n    debug('_parsePayload complete result: %s', result)\n    return result\n  }\n\n  _parseConnect () {\n    debug('_parseConnect')\n    let topic // Will topic\n    let payload // Will payload\n    let password // Password\n    let username // Username\n    const flags = {}\n    const packet = this.packet\n\n    // Parse protocolId\n    const protocolId = this._parseString()\n\n    if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n    if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n      return this._emitError(new Error('Invalid protocolId'))\n    }\n\n    packet.protocolId = protocolId\n\n    // Parse constants version number\n    if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n    packet.protocolVersion = this._list.readUInt8(this._pos)\n\n    if (packet.protocolVersion >= 128) {\n      packet.bridgeMode = true\n      packet.protocolVersion = packet.protocolVersion - 128\n    }\n\n    if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n      return this._emitError(new Error('Invalid protocol version'))\n    }\n\n    this._pos++\n\n    if (this._pos >= this._list.length) {\n      return this._emitError(new Error('Packet too short'))\n    }\n\n    if (this._list.readUInt8(this._pos) & 0x1) {\n      // The Server MUST validate that the reserved flag in the CONNECT Control Packet is set to zero and disconnect the Client if it is not zero [MQTT-3.1.2-3]\n      return this._emitError(new Error('Connect flag bit 0 must be 0, but got 1'))\n    }\n    // Parse connect flags\n    flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n    flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n    flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n    const willRetain = !!(this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK)\n    const willQos = (this._list.readUInt8(this._pos) &\n        constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n\n    if (flags.will) {\n      packet.will = {}\n      packet.will.retain = willRetain\n      packet.will.qos = willQos\n    } else {\n      if (willRetain) {\n        return this._emitError(new Error('Will Retain Flag must be set to zero when Will Flag is set to 0'))\n      }\n      if (willQos) {\n        return this._emitError(new Error('Will QoS must be set to zero when Will Flag is set to 0'))\n      }\n    }\n\n    packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n    this._pos++\n\n    // Parse keepalive\n    packet.keepalive = this._parseNum()\n    if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n    // parse properties\n    if (packet.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    // Parse clientId\n    const clientId = this._parseString()\n    if (clientId === null) return this._emitError(new Error('Packet too short'))\n    packet.clientId = clientId\n    debug('_parseConnect: packet.clientId: %s', packet.clientId)\n\n    if (flags.will) {\n      if (packet.protocolVersion === 5) {\n        const willProperties = this._parseProperties()\n        if (Object.getOwnPropertyNames(willProperties).length) {\n          packet.will.properties = willProperties\n        }\n      }\n      // Parse will topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n      packet.will.topic = topic\n      debug('_parseConnect: packet.will.topic: %s', packet.will.topic)\n\n      // Parse will payload\n      payload = this._parseBuffer()\n      if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n      packet.will.payload = payload\n      debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload)\n    }\n\n    // Parse username\n    if (flags.username) {\n      username = this._parseString()\n      if (username === null) return this._emitError(new Error('Cannot parse username'))\n      packet.username = username\n      debug('_parseConnect: packet.username: %s', packet.username)\n    }\n\n    // Parse password\n    if (flags.password) {\n      password = this._parseBuffer()\n      if (password === null) return this._emitError(new Error('Cannot parse password'))\n      packet.password = password\n    }\n    // need for right parse auth packet and self set up\n    this.settings = packet\n    debug('_parseConnect: complete')\n    return packet\n  }\n\n  _parseConnack () {\n    debug('_parseConnack')\n    const packet = this.packet\n\n    if (this._list.length < 1) return null\n    const flags = this._list.readUInt8(this._pos++)\n    if (flags > 1) {\n      return this._emitError(new Error('Invalid connack flags, bits 7-1 must be set to 0'))\n    }\n    packet.sessionPresent = !!(flags & constants.SESSIONPRESENT_MASK)\n\n    if (this.settings.protocolVersion === 5) {\n      if (this._list.length >= 2) {\n        packet.reasonCode = this._list.readUInt8(this._pos++)\n      } else {\n        packet.reasonCode = 0\n      }\n    } else {\n      if (this._list.length < 2) return null\n      packet.returnCode = this._list.readUInt8(this._pos++)\n    }\n\n    if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'))\n    // mqtt 5 properties\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n    debug('_parseConnack: complete')\n  }\n\n  _parsePublish () {\n    debug('_parsePublish')\n    const packet = this.packet\n    packet.topic = this._parseString()\n\n    if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Parse messageId\n    if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    packet.payload = this._list.slice(this._pos, packet.length)\n    debug('_parsePublish: payload from buffer list: %o', packet.payload)\n  }\n\n  _parseSubscribe () {\n    debug('_parseSubscribe')\n    const packet = this.packet\n    let topic\n    let options\n    let qos\n    let rh\n    let rap\n    let nl\n    let subscription\n\n    packet.subscriptions = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed subscribe, no payload specified')) }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n      if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n\n      options = this._parseByte()\n\n      if (this.settings.protocolVersion === 5) {\n        if (options & 0xc0) {\n          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-6 must be 0'))\n        }\n      } else {\n        if (options & 0xfc) {\n          return this._emitError(new Error('Invalid subscribe topic flag bits, bits 7-2 must be 0'))\n        }\n      }\n\n      qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK\n      if (qos > 2) {\n        return this._emitError(new Error('Invalid subscribe QoS, must be <= 2'))\n      }\n      nl = ((options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT) & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0\n      rap = ((options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT) & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0\n      rh = (options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT) & constants.SUBSCRIBE_OPTIONS_RH_MASK\n\n      if (rh > 2) {\n        return this._emitError(new Error('Invalid retain handling, must be <= 2'))\n      }\n\n      subscription = { topic, qos }\n\n      // mqtt 5 options\n      if (this.settings.protocolVersion === 5) {\n        subscription.nl = nl\n        subscription.rap = rap\n        subscription.rh = rh\n      } else if (this.settings.bridgeMode) {\n        subscription.rh = 0\n        subscription.rap = true\n        subscription.nl = true\n      }\n\n      // Push pair to subscriptions\n      debug('_parseSubscribe: push subscription `%s` to subscription', subscription)\n      packet.subscriptions.push(subscription)\n    }\n  }\n\n  _parseSuback () {\n    debug('_parseSuback')\n    const packet = this.packet\n    this.packet.granted = []\n\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed suback, no payload specified')) }\n\n    // Parse granted QoSes\n    while (this._pos < this.packet.length) {\n      const code = this._list.readUInt8(this._pos++)\n      if (this.settings.protocolVersion === 5) {\n        if (!constants.MQTT5_SUBACK_CODES[code]) {\n          return this._emitError(new Error('Invalid suback code'))\n        }\n      } else {\n        if (code > 2 && code !== 0x80) {\n          return this._emitError(new Error('Invalid suback QoS, must be 0, 1, 2 or 128'))\n        }\n      }\n      this.packet.granted.push(code)\n    }\n  }\n\n  _parseUnsubscribe () {\n    debug('_parseUnsubscribe')\n    const packet = this.packet\n\n    packet.unsubscriptions = []\n\n    // Parse messageId\n    if (!this._parseMessageId()) { return }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed unsubscribe, no payload specified')) }\n\n    while (this._pos < packet.length) {\n      // Parse topic\n      const topic = this._parseString()\n      if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n      // Push topic to unsubscriptions\n      debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic)\n      packet.unsubscriptions.push(topic)\n    }\n  }\n\n  _parseUnsuback () {\n    debug('_parseUnsuback')\n    const packet = this.packet\n    if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n\n    if ((this.settings.protocolVersion === 3 ||\n      this.settings.protocolVersion === 4) && packet.length !== 2) {\n      return this._emitError(new Error('Malformed unsuback, payload length must be 2'))\n    }\n    if (packet.length <= 0) { return this._emitError(new Error('Malformed unsuback, no payload specified')) }\n\n    // Properties mqtt 5\n    if (this.settings.protocolVersion === 5) {\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n      // Parse granted QoSes\n      packet.granted = []\n\n      while (this._pos < this.packet.length) {\n        const code = this._list.readUInt8(this._pos++)\n        if (!constants.MQTT5_UNSUBACK_CODES[code]) {\n          return this._emitError(new Error('Invalid unsuback code'))\n        }\n        this.packet.granted.push(code)\n      }\n    }\n  }\n\n  // parse packets like puback, pubrec, pubrel, pubcomp\n  _parseConfirmation () {\n    debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd)\n    const packet = this.packet\n\n    this._parseMessageId()\n\n    if (this.settings.protocolVersion === 5) {\n      if (packet.length > 2) {\n        // response code\n        packet.reasonCode = this._parseByte()\n        switch (this.packet.cmd) {\n          case 'puback':\n          case 'pubrec':\n            if (!constants.MQTT5_PUBACK_PUBREC_CODES[packet.reasonCode]) {\n              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'))\n            }\n            break\n          case 'pubrel':\n          case 'pubcomp':\n            if (!constants.MQTT5_PUBREL_PUBCOMP_CODES[packet.reasonCode]) {\n              return this._emitError(new Error('Invalid ' + this.packet.cmd + ' reason code'))\n            }\n            break\n        }\n        debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode)\n      } else {\n        packet.reasonCode = 0\n      }\n\n      if (packet.length > 3) {\n        // properies mqtt 5\n        const properties = this._parseProperties()\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties\n        }\n      }\n    }\n\n    return true\n  }\n\n  // parse disconnect packet\n  _parseDisconnect () {\n    const packet = this.packet\n    debug('_parseDisconnect')\n\n    if (this.settings.protocolVersion === 5) {\n      // response code\n      if (this._list.length > 0) {\n        packet.reasonCode = this._parseByte()\n        if (!constants.MQTT5_DISCONNECT_CODES[packet.reasonCode]) {\n          this._emitError(new Error('Invalid disconnect reason code'))\n        }\n      } else {\n        packet.reasonCode = 0\n      }\n      // properies mqtt 5\n      const properties = this._parseProperties()\n      if (Object.getOwnPropertyNames(properties).length) {\n        packet.properties = properties\n      }\n    }\n\n    debug('_parseDisconnect result: true')\n    return true\n  }\n\n  // parse auth packet\n  _parseAuth () {\n    debug('_parseAuth')\n    const packet = this.packet\n\n    if (this.settings.protocolVersion !== 5) {\n      return this._emitError(new Error('Not supported auth packet for this version MQTT'))\n    }\n\n    // response code\n    packet.reasonCode = this._parseByte()\n    if (!constants.MQTT5_AUTH_CODES[packet.reasonCode]) {\n      return this._emitError(new Error('Invalid auth reason code'))\n    }\n    // properies mqtt 5\n    const properties = this._parseProperties()\n    if (Object.getOwnPropertyNames(properties).length) {\n      packet.properties = properties\n    }\n\n    debug('_parseAuth: result: true')\n    return true\n  }\n\n  _parseMessageId () {\n    const packet = this.packet\n\n    packet.messageId = this._parseNum()\n\n    if (packet.messageId === null) {\n      this._emitError(new Error('Cannot parse messageId'))\n      return false\n    }\n\n    debug('_parseMessageId: packet.messageId %d', packet.messageId)\n    return true\n  }\n\n  _parseString (maybeBuffer) {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.toString('utf8', this._pos, end)\n    this._pos += length\n    debug('_parseString: result: %s', result)\n    return result\n  }\n\n  _parseStringPair () {\n    debug('_parseStringPair')\n    return {\n      name: this._parseString(),\n      value: this._parseString()\n    }\n  }\n\n  _parseBuffer () {\n    const length = this._parseNum()\n    const end = length + this._pos\n\n    if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n    const result = this._list.slice(this._pos, end)\n\n    this._pos += length\n    debug('_parseBuffer: result: %o', result)\n    return result\n  }\n\n  _parseNum () {\n    if (this._list.length - this._pos < 2) return -1\n\n    const result = this._list.readUInt16BE(this._pos)\n    this._pos += 2\n    debug('_parseNum: result: %s', result)\n    return result\n  }\n\n  _parse4ByteNum () {\n    if (this._list.length - this._pos < 4) return -1\n\n    const result = this._list.readUInt32BE(this._pos)\n    this._pos += 4\n    debug('_parse4ByteNum: result: %s', result)\n    return result\n  }\n\n  _parseVarByteNum (fullInfoFlag) {\n    debug('_parseVarByteNum')\n    const maxBytes = 4\n    let bytes = 0\n    let mul = 1\n    let value = 0\n    let result = false\n    let current\n    const padding = this._pos ? this._pos : 0\n\n    while (bytes < maxBytes && (padding + bytes) < this._list.length) {\n      current = this._list.readUInt8(padding + bytes++)\n      value += mul * (current & constants.VARBYTEINT_MASK)\n      mul *= 0x80\n\n      if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n        result = true\n        break\n      }\n      if (this._list.length <= bytes) {\n        break\n      }\n    }\n\n    if (!result && bytes === maxBytes && this._list.length >= bytes) {\n      this._emitError(new Error('Invalid variable byte integer'))\n    }\n\n    if (padding) {\n      this._pos += bytes\n    }\n\n    if (result) {\n      if (fullInfoFlag) {\n        result = { bytes, value }\n      } else {\n        result = value\n      }\n    } else {\n      result = false\n    }\n\n    debug('_parseVarByteNum: result: %o', result)\n    return result\n  }\n\n  _parseByte () {\n    let result\n    if (this._pos < this._list.length) {\n      result = this._list.readUInt8(this._pos)\n      this._pos++\n    }\n    debug('_parseByte: result: %o', result)\n    return result\n  }\n\n  _parseByType (type) {\n    debug('_parseByType: type: %s', type)\n    switch (type) {\n      case 'byte': {\n        return this._parseByte() !== 0\n      }\n      case 'int8': {\n        return this._parseByte()\n      }\n      case 'int16': {\n        return this._parseNum()\n      }\n      case 'int32': {\n        return this._parse4ByteNum()\n      }\n      case 'var': {\n        return this._parseVarByteNum()\n      }\n      case 'string': {\n        return this._parseString()\n      }\n      case 'pair': {\n        return this._parseStringPair()\n      }\n      case 'binary': {\n        return this._parseBuffer()\n      }\n    }\n  }\n\n  _parseProperties () {\n    debug('_parseProperties')\n    const length = this._parseVarByteNum()\n    const start = this._pos\n    const end = start + length\n    const result = {}\n    while (this._pos < end) {\n      const type = this._parseByte()\n      if (!type) {\n        this._emitError(new Error('Cannot parse property code type'))\n        return false\n      }\n      const name = constants.propertiesCodes[type]\n      if (!name) {\n        this._emitError(new Error('Unknown property'))\n        return false\n      }\n      // user properties process\n      if (name === 'userProperties') {\n        if (!result[name]) {\n          result[name] = Object.create(null)\n        }\n        const currentUserProperty = this._parseByType(constants.propertiesTypes[name])\n        if (result[name][currentUserProperty.name]) {\n          if (Array.isArray(result[name][currentUserProperty.name])) {\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          } else {\n            const currentValue = result[name][currentUserProperty.name]\n            result[name][currentUserProperty.name] = [currentValue]\n            result[name][currentUserProperty.name].push(currentUserProperty.value)\n          }\n        } else {\n          result[name][currentUserProperty.name] = currentUserProperty.value\n        }\n        continue\n      }\n      if (result[name]) {\n        if (Array.isArray(result[name])) {\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        } else {\n          result[name] = [result[name]]\n          result[name].push(this._parseByType(constants.propertiesTypes[name]))\n        }\n      } else {\n        result[name] = this._parseByType(constants.propertiesTypes[name])\n      }\n    }\n    return result\n  }\n\n  _newPacket () {\n    debug('_newPacket')\n    if (this.packet) {\n      this._list.consume(this.packet.length)\n      debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length)\n      this.emit('packet', this.packet)\n    }\n    debug('_newPacket: new packet')\n    this.packet = new Packet()\n\n    this._pos = 0\n\n    return true\n  }\n\n  _emitError (err) {\n    debug('_emitError', err)\n    this.error = err\n    this.emit('error', err)\n  }\n}\n\nmodule.exports = Parser\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyx5Q0FBSTtBQUN2QixRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw0REFBVTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUN2QyxjQUFjLG1CQUFPLENBQUMsc0RBQU87O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xkLXN0b3JhZ2Utc3lzdGVtLy4vbm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L3BhcnNlci5qcz8wZDQxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJsID0gcmVxdWlyZSgnYmwnKVxuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBQYWNrZXQgPSByZXF1aXJlKCcuL3BhY2tldCcpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdHQtcGFja2V0OnBhcnNlcicpXG5cbmNsYXNzIFBhcnNlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5wYXJzZXIgPSB0aGlzLmNvbnN0cnVjdG9yLnBhcnNlclxuICB9XG5cbiAgc3RhdGljIHBhcnNlciAob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhcnNlcikpIHJldHVybiAobmV3IFBhcnNlcigpKS5wYXJzZXIob3B0KVxuXG4gICAgdGhpcy5zZXR0aW5ncyA9IG9wdCB8fCB7fVxuXG4gICAgdGhpcy5fc3RhdGVzID0gW1xuICAgICAgJ19wYXJzZUhlYWRlcicsXG4gICAgICAnX3BhcnNlTGVuZ3RoJyxcbiAgICAgICdfcGFyc2VQYXlsb2FkJyxcbiAgICAgICdfbmV3UGFja2V0J1xuICAgIF1cblxuICAgIHRoaXMuX3Jlc2V0U3RhdGUoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfcmVzZXRTdGF0ZSAoKSB7XG4gICAgZGVidWcoJ19yZXNldFN0YXRlOiByZXNldHRpbmcgcGFja2V0LCBlcnJvciwgX2xpc3QsIGFuZCBfc3RhdGVDb3VudGVyJylcbiAgICB0aGlzLnBhY2tldCA9IG5ldyBQYWNrZXQoKVxuICAgIHRoaXMuZXJyb3IgPSBudWxsXG4gICAgdGhpcy5fbGlzdCA9IGJsKClcbiAgICB0aGlzLl9zdGF0ZUNvdW50ZXIgPSAwXG4gIH1cblxuICBwYXJzZSAoYnVmKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHRoaXMuX3Jlc2V0U3RhdGUoKVxuXG4gICAgdGhpcy5fbGlzdC5hcHBlbmQoYnVmKVxuICAgIGRlYnVnKCdwYXJzZTogY3VycmVudCBzdGF0ZTogJXMnLCB0aGlzLl9zdGF0ZXNbdGhpcy5fc3RhdGVDb3VudGVyXSlcbiAgICB3aGlsZSAoKHRoaXMucGFja2V0Lmxlbmd0aCAhPT0gLTEgfHwgdGhpcy5fbGlzdC5sZW5ndGggPiAwKSAmJlxuICAgICAgdGhpc1t0aGlzLl9zdGF0ZXNbdGhpcy5fc3RhdGVDb3VudGVyXV0oKSAmJlxuICAgICAgIXRoaXMuZXJyb3IpIHtcbiAgICAgIHRoaXMuX3N0YXRlQ291bnRlcisrXG4gICAgICBkZWJ1ZygncGFyc2U6IHN0YXRlIGNvbXBsZXRlLiBfc3RhdGVDb3VudGVyIGlzIG5vdzogJWQnLCB0aGlzLl9zdGF0ZUNvdW50ZXIpXG4gICAgICBkZWJ1ZygncGFyc2U6IHBhY2tldC5sZW5ndGg6ICVkLCBidWZmZXIgbGlzdCBsZW5ndGg6ICVkJywgdGhpcy5wYWNrZXQubGVuZ3RoLCB0aGlzLl9saXN0Lmxlbmd0aClcbiAgICAgIGlmICh0aGlzLl9zdGF0ZUNvdW50ZXIgPj0gdGhpcy5fc3RhdGVzLmxlbmd0aCkgdGhpcy5fc3RhdGVDb3VudGVyID0gMFxuICAgIH1cbiAgICBkZWJ1ZygncGFyc2U6IGV4aXRlZCB3aGlsZSBsb29wLiBwYWNrZXQ6ICVkLCBidWZmZXIgbGlzdCBsZW5ndGg6ICVkJywgdGhpcy5wYWNrZXQubGVuZ3RoLCB0aGlzLl9saXN0Lmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGhcbiAgfVxuXG4gIF9wYXJzZUhlYWRlciAoKSB7XG4gICAgLy8gVGhlcmUgaXMgYXQgbGVhc3Qgb25lIGJ5dGUgaW4gdGhlIGJ1ZmZlclxuICAgIGNvbnN0IHplcm8gPSB0aGlzLl9saXN0LnJlYWRVSW50OCgwKVxuICAgIGNvbnN0IGNtZEluZGV4ID0gemVybyA+PiBjb25zdGFudHMuQ01EX1NISUZUXG4gICAgdGhpcy5wYWNrZXQuY21kID0gY29uc3RhbnRzLnR5cGVzW2NtZEluZGV4XVxuICAgIGNvbnN0IGhlYWRlckZsYWdzID0gemVybyAmIDB4ZlxuICAgIGNvbnN0IHJlcXVpcmVkSGVhZGVyRmxhZ3MgPSBjb25zdGFudHMucmVxdWlyZWRIZWFkZXJGbGFnc1tjbWRJbmRleF1cbiAgICBpZiAocmVxdWlyZWRIZWFkZXJGbGFncyAhPSBudWxsICYmIGhlYWRlckZsYWdzICE9PSByZXF1aXJlZEhlYWRlckZsYWdzKSB7XG4gICAgICAvLyBXaGVyZSBhIGZsYWcgYml0IGlzIG1hcmtlZCBhcyDigJxSZXNlcnZlZOKAnSBpbiBUYWJsZSAyLjIgLSBGbGFnIEJpdHMsIGl0IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGFuZCBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgbGlzdGVkIGluIHRoYXQgdGFibGUgW01RVFQtMi4yLjItMV0uIElmIGludmFsaWQgZmxhZ3MgYXJlIHJlY2VpdmVkLCB0aGUgcmVjZWl2ZXIgTVVTVCBjbG9zZSB0aGUgTmV0d29yayBDb25uZWN0aW9uIFtNUVRULTIuMi4yLTJdXG4gICAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihjb25zdGFudHMucmVxdWlyZWRIZWFkZXJGbGFnc0Vycm9yc1tjbWRJbmRleF0pKVxuICAgIH1cbiAgICB0aGlzLnBhY2tldC5yZXRhaW4gPSAoemVybyAmIGNvbnN0YW50cy5SRVRBSU5fTUFTSykgIT09IDBcbiAgICB0aGlzLnBhY2tldC5xb3MgPSAoemVybyA+PiBjb25zdGFudHMuUU9TX1NISUZUKSAmIGNvbnN0YW50cy5RT1NfTUFTS1xuICAgIGlmICh0aGlzLnBhY2tldC5xb3MgPiAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IG11c3Qgbm90IGhhdmUgYm90aCBRb1MgYml0cyBzZXQgdG8gMScpKVxuICAgIH1cbiAgICB0aGlzLnBhY2tldC5kdXAgPSAoemVybyAmIGNvbnN0YW50cy5EVVBfTUFTSykgIT09IDBcbiAgICBkZWJ1ZygnX3BhcnNlSGVhZGVyOiBwYWNrZXQ6ICVvJywgdGhpcy5wYWNrZXQpXG5cbiAgICB0aGlzLl9saXN0LmNvbnN1bWUoMSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfcGFyc2VMZW5ndGggKCkge1xuICAgIC8vIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBieXRlIGluIHRoZSBsaXN0XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKHRydWUpXG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLnBhY2tldC5sZW5ndGggPSByZXN1bHQudmFsdWVcbiAgICAgIHRoaXMuX2xpc3QuY29uc3VtZShyZXN1bHQuYnl0ZXMpXG4gICAgfVxuICAgIGRlYnVnKCdfcGFyc2VMZW5ndGggJWQnLCByZXN1bHQudmFsdWUpXG4gICAgcmV0dXJuICEhcmVzdWx0XG4gIH1cblxuICBfcGFyc2VQYXlsb2FkICgpIHtcbiAgICBkZWJ1ZygnX3BhcnNlUGF5bG9hZDogcGF5bG9hZCAlTycsIHRoaXMuX2xpc3QpXG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlXG5cbiAgICAvLyBEbyB3ZSBoYXZlIGEgcGF5bG9hZD8gRG8gd2UgaGF2ZSBlbm91Z2ggZGF0YSB0byBjb21wbGV0ZSB0aGUgcGF5bG9hZD9cbiAgICAvLyBQSU5HcyBoYXZlIG5vIHBheWxvYWRcbiAgICBpZiAodGhpcy5wYWNrZXQubGVuZ3RoID09PSAwIHx8IHRoaXMuX2xpc3QubGVuZ3RoID49IHRoaXMucGFja2V0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fcG9zID0gMFxuXG4gICAgICBzd2l0Y2ggKHRoaXMucGFja2V0LmNtZCkge1xuICAgICAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgICAgICB0aGlzLl9wYXJzZUNvbm5lY3QoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2Nvbm5hY2snOlxuICAgICAgICAgIHRoaXMuX3BhcnNlQ29ubmFjaygpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncHVibGlzaCc6XG4gICAgICAgICAgdGhpcy5fcGFyc2VQdWJsaXNoKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwdWJhY2snOlxuICAgICAgICBjYXNlICdwdWJyZWMnOlxuICAgICAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgICBjYXNlICdwdWJjb21wJzpcbiAgICAgICAgICB0aGlzLl9wYXJzZUNvbmZpcm1hdGlvbigpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlJzpcbiAgICAgICAgICB0aGlzLl9wYXJzZVN1YnNjcmliZSgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3ViYWNrJzpcbiAgICAgICAgICB0aGlzLl9wYXJzZVN1YmFjaygpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndW5zdWJzY3JpYmUnOlxuICAgICAgICAgIHRoaXMuX3BhcnNlVW5zdWJzY3JpYmUoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgICAgICB0aGlzLl9wYXJzZVVuc3ViYWNrKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwaW5ncmVxJzpcbiAgICAgICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgICAgIC8vIFRoZXNlIGFyZSBlbXB0eSwgbm90aGluZyB0byBkb1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuX3BhcnNlRGlzY29ubmVjdCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnYXV0aCc6XG4gICAgICAgICAgdGhpcy5fcGFyc2VBdXRoKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKSlcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gdHJ1ZVxuICAgIH1cbiAgICBkZWJ1ZygnX3BhcnNlUGF5bG9hZCBjb21wbGV0ZSByZXN1bHQ6ICVzJywgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIF9wYXJzZUNvbm5lY3QgKCkge1xuICAgIGRlYnVnKCdfcGFyc2VDb25uZWN0JylcbiAgICBsZXQgdG9waWMgLy8gV2lsbCB0b3BpY1xuICAgIGxldCBwYXlsb2FkIC8vIFdpbGwgcGF5bG9hZFxuICAgIGxldCBwYXNzd29yZCAvLyBQYXNzd29yZFxuICAgIGxldCB1c2VybmFtZSAvLyBVc2VybmFtZVxuICAgIGNvbnN0IGZsYWdzID0ge31cbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gICAgLy8gUGFyc2UgcHJvdG9jb2xJZFxuICAgIGNvbnN0IHByb3RvY29sSWQgPSB0aGlzLl9wYXJzZVN0cmluZygpXG5cbiAgICBpZiAocHJvdG9jb2xJZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBwcm90b2NvbElkJykpXG4gICAgaWYgKHByb3RvY29sSWQgIT09ICdNUVRUJyAmJiBwcm90b2NvbElkICE9PSAnTVFJc2RwJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2xJZCcpKVxuICAgIH1cblxuICAgIHBhY2tldC5wcm90b2NvbElkID0gcHJvdG9jb2xJZFxuXG4gICAgLy8gUGFyc2UgY29uc3RhbnRzIHZlcnNpb24gbnVtYmVyXG4gICAgaWYgKHRoaXMuX3BvcyA+PSB0aGlzLl9saXN0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcblxuICAgIHBhY2tldC5wcm90b2NvbFZlcnNpb24gPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG5cbiAgICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiA+PSAxMjgpIHtcbiAgICAgIHBhY2tldC5icmlkZ2VNb2RlID0gdHJ1ZVxuICAgICAgcGFja2V0LnByb3RvY29sVmVyc2lvbiA9IHBhY2tldC5wcm90b2NvbFZlcnNpb24gLSAxMjhcbiAgICB9XG5cbiAgICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiAhPT0gMyAmJiBwYWNrZXQucHJvdG9jb2xWZXJzaW9uICE9PSA0ICYmIHBhY2tldC5wcm90b2NvbFZlcnNpb24gIT09IDUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sIHZlcnNpb24nKSlcbiAgICB9XG5cbiAgICB0aGlzLl9wb3MrK1xuXG4gICAgaWYgKHRoaXMuX3BvcyA+PSB0aGlzLl9saXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIDB4MSkge1xuICAgICAgLy8gVGhlIFNlcnZlciBNVVNUIHZhbGlkYXRlIHRoYXQgdGhlIHJlc2VydmVkIGZsYWcgaW4gdGhlIENPTk5FQ1QgQ29udHJvbCBQYWNrZXQgaXMgc2V0IHRvIHplcm8gYW5kIGRpc2Nvbm5lY3QgdGhlIENsaWVudCBpZiBpdCBpcyBub3QgemVybyBbTVFUVC0zLjEuMi0zXVxuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nvbm5lY3QgZmxhZyBiaXQgMCBtdXN0IGJlIDAsIGJ1dCBnb3QgMScpKVxuICAgIH1cbiAgICAvLyBQYXJzZSBjb25uZWN0IGZsYWdzXG4gICAgZmxhZ3MudXNlcm5hbWUgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5VU0VSTkFNRV9NQVNLKVxuICAgIGZsYWdzLnBhc3N3b3JkID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuUEFTU1dPUkRfTUFTSylcbiAgICBmbGFncy53aWxsID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuV0lMTF9GTEFHX01BU0spXG5cbiAgICBjb25zdCB3aWxsUmV0YWluID0gISEodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX1JFVEFJTl9NQVNLKVxuICAgIGNvbnN0IHdpbGxRb3MgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmXG4gICAgICAgIGNvbnN0YW50cy5XSUxMX1FPU19NQVNLKSA+PiBjb25zdGFudHMuV0lMTF9RT1NfU0hJRlRcblxuICAgIGlmIChmbGFncy53aWxsKSB7XG4gICAgICBwYWNrZXQud2lsbCA9IHt9XG4gICAgICBwYWNrZXQud2lsbC5yZXRhaW4gPSB3aWxsUmV0YWluXG4gICAgICBwYWNrZXQud2lsbC5xb3MgPSB3aWxsUW9zXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3aWxsUmV0YWluKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdXaWxsIFJldGFpbiBGbGFnIG11c3QgYmUgc2V0IHRvIHplcm8gd2hlbiBXaWxsIEZsYWcgaXMgc2V0IHRvIDAnKSlcbiAgICAgIH1cbiAgICAgIGlmICh3aWxsUW9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdXaWxsIFFvUyBtdXN0IGJlIHNldCB0byB6ZXJvIHdoZW4gV2lsbCBGbGFnIGlzIHNldCB0byAwJykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFja2V0LmNsZWFuID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuQ0xFQU5fU0VTU0lPTl9NQVNLKSAhPT0gMFxuICAgIHRoaXMuX3BvcysrXG5cbiAgICAvLyBQYXJzZSBrZWVwYWxpdmVcbiAgICBwYWNrZXQua2VlcGFsaXZlID0gdGhpcy5fcGFyc2VOdW0oKVxuICAgIGlmIChwYWNrZXQua2VlcGFsaXZlID09PSAtMSkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcblxuICAgIC8vIHBhcnNlIHByb3BlcnRpZXNcbiAgICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBjbGllbnRJZFxuICAgIGNvbnN0IGNsaWVudElkID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmIChjbGllbnRJZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgICBwYWNrZXQuY2xpZW50SWQgPSBjbGllbnRJZFxuICAgIGRlYnVnKCdfcGFyc2VDb25uZWN0OiBwYWNrZXQuY2xpZW50SWQ6ICVzJywgcGFja2V0LmNsaWVudElkKVxuXG4gICAgaWYgKGZsYWdzLndpbGwpIHtcbiAgICAgIGlmIChwYWNrZXQucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICAgIGNvbnN0IHdpbGxQcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbGxQcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgICAgICBwYWNrZXQud2lsbC5wcm9wZXJ0aWVzID0gd2lsbFByb3BlcnRpZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUGFyc2Ugd2lsbCB0b3BpY1xuICAgICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCB0b3BpYycpKVxuICAgICAgcGFja2V0LndpbGwudG9waWMgPSB0b3BpY1xuICAgICAgZGVidWcoJ19wYXJzZUNvbm5lY3Q6IHBhY2tldC53aWxsLnRvcGljOiAlcycsIHBhY2tldC53aWxsLnRvcGljKVxuXG4gICAgICAvLyBQYXJzZSB3aWxsIHBheWxvYWRcbiAgICAgIHBheWxvYWQgPSB0aGlzLl9wYXJzZUJ1ZmZlcigpXG4gICAgICBpZiAocGF5bG9hZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB3aWxsIHBheWxvYWQnKSlcbiAgICAgIHBhY2tldC53aWxsLnBheWxvYWQgPSBwYXlsb2FkXG4gICAgICBkZWJ1ZygnX3BhcnNlQ29ubmVjdDogcGFja2V0LndpbGwucGF5bGFvZDogJXMnLCBwYWNrZXQud2lsbC5wYXlsb2FkKVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHVzZXJuYW1lXG4gICAgaWYgKGZsYWdzLnVzZXJuYW1lKSB7XG4gICAgICB1c2VybmFtZSA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICAgIGlmICh1c2VybmFtZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB1c2VybmFtZScpKVxuICAgICAgcGFja2V0LnVzZXJuYW1lID0gdXNlcm5hbWVcbiAgICAgIGRlYnVnKCdfcGFyc2VDb25uZWN0OiBwYWNrZXQudXNlcm5hbWU6ICVzJywgcGFja2V0LnVzZXJuYW1lKVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHBhc3N3b3JkXG4gICAgaWYgKGZsYWdzLnBhc3N3b3JkKSB7XG4gICAgICBwYXNzd29yZCA9IHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICAgIGlmIChwYXNzd29yZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBwYXNzd29yZCcpKVxuICAgICAgcGFja2V0LnBhc3N3b3JkID0gcGFzc3dvcmRcbiAgICB9XG4gICAgLy8gbmVlZCBmb3IgcmlnaHQgcGFyc2UgYXV0aCBwYWNrZXQgYW5kIHNlbGYgc2V0IHVwXG4gICAgdGhpcy5zZXR0aW5ncyA9IHBhY2tldFxuICAgIGRlYnVnKCdfcGFyc2VDb25uZWN0OiBjb21wbGV0ZScpXG4gICAgcmV0dXJuIHBhY2tldFxuICB9XG5cbiAgX3BhcnNlQ29ubmFjayAoKSB7XG4gICAgZGVidWcoJ19wYXJzZUNvbm5hY2snKVxuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPCAxKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspXG4gICAgaWYgKGZsYWdzID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgY29ubmFjayBmbGFncywgYml0cyA3LTEgbXVzdCBiZSBzZXQgdG8gMCcpKVxuICAgIH1cbiAgICBwYWNrZXQuc2Vzc2lvblByZXNlbnQgPSAhIShmbGFncyAmIGNvbnN0YW50cy5TRVNTSU9OUFJFU0VOVF9NQVNLKVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICBwYWNrZXQucmVhc29uQ29kZSA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFja2V0LnJlYXNvbkNvZGUgPSAwXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8IDIpIHJldHVybiBudWxsXG4gICAgICBwYWNrZXQucmV0dXJuQ29kZSA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKVxuICAgIH1cblxuICAgIGlmIChwYWNrZXQucmV0dXJuQ29kZSA9PT0gLTEgfHwgcGFja2V0LnJlYXNvbkNvZGUgPT09IC0xKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHJldHVybiBjb2RlJykpXG4gICAgLy8gbXF0dCA1IHByb3BlcnRpZXNcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoJ19wYXJzZUNvbm5hY2s6IGNvbXBsZXRlJylcbiAgfVxuXG4gIF9wYXJzZVB1Ymxpc2ggKCkge1xuICAgIGRlYnVnKCdfcGFyc2VQdWJsaXNoJylcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICAgIHBhY2tldC50b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcblxuICAgIGlmIChwYWNrZXQudG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAgIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICAgIGlmIChwYWNrZXQucW9zID4gMCkgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhY2tldC5wYXlsb2FkID0gdGhpcy5fbGlzdC5zbGljZSh0aGlzLl9wb3MsIHBhY2tldC5sZW5ndGgpXG4gICAgZGVidWcoJ19wYXJzZVB1Ymxpc2g6IHBheWxvYWQgZnJvbSBidWZmZXIgbGlzdDogJW8nLCBwYWNrZXQucGF5bG9hZClcbiAgfVxuXG4gIF9wYXJzZVN1YnNjcmliZSAoKSB7XG4gICAgZGVidWcoJ19wYXJzZVN1YnNjcmliZScpXG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgICBsZXQgdG9waWNcbiAgICBsZXQgb3B0aW9uc1xuICAgIGxldCBxb3NcbiAgICBsZXQgcmhcbiAgICBsZXQgcmFwXG4gICAgbGV0IG5sXG4gICAgbGV0IHN1YnNjcmlwdGlvblxuXG4gICAgcGFja2V0LnN1YnNjcmlwdGlvbnMgPSBbXVxuXG4gICAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYWNrZXQubGVuZ3RoIDw9IDApIHsgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBzdWJzY3JpYmUsIG5vIHBheWxvYWQgc3BlY2lmaWVkJykpIH1cblxuICAgIHdoaWxlICh0aGlzLl9wb3MgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgICAvLyBQYXJzZSB0b3BpY1xuICAgICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcbiAgICAgIGlmICh0aGlzLl9wb3MgPj0gcGFja2V0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBTdWJzY3JpYmUgUGF5bG9hZCcpKVxuXG4gICAgICBvcHRpb25zID0gdGhpcy5fcGFyc2VCeXRlKClcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICAgIGlmIChvcHRpb25zICYgMHhjMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmliZSB0b3BpYyBmbGFnIGJpdHMsIGJpdHMgNy02IG11c3QgYmUgMCcpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucyAmIDB4ZmMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpYmUgdG9waWMgZmxhZyBiaXRzLCBiaXRzIDctMiBtdXN0IGJlIDAnKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxb3MgPSBvcHRpb25zICYgY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1FPU19NQVNLXG4gICAgICBpZiAocW9zID4gMikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpYmUgUW9TLCBtdXN0IGJlIDw9IDInKSlcbiAgICAgIH1cbiAgICAgIG5sID0gKChvcHRpb25zID4+IGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCkgJiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfTkxfTUFTSykgIT09IDBcbiAgICAgIHJhcCA9ICgob3B0aW9ucyA+PiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUKSAmIGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19SQVBfTUFTSykgIT09IDBcbiAgICAgIHJoID0gKG9wdGlvbnMgPj4gY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1JIX1NISUZUKSAmIGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19SSF9NQVNLXG5cbiAgICAgIGlmIChyaCA+IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcmV0YWluIGhhbmRsaW5nLCBtdXN0IGJlIDw9IDInKSlcbiAgICAgIH1cblxuICAgICAgc3Vic2NyaXB0aW9uID0geyB0b3BpYywgcW9zIH1cblxuICAgICAgLy8gbXF0dCA1IG9wdGlvbnNcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgICBzdWJzY3JpcHRpb24ubmwgPSBubFxuICAgICAgICBzdWJzY3JpcHRpb24ucmFwID0gcmFwXG4gICAgICAgIHN1YnNjcmlwdGlvbi5yaCA9IHJoXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuYnJpZGdlTW9kZSkge1xuICAgICAgICBzdWJzY3JpcHRpb24ucmggPSAwXG4gICAgICAgIHN1YnNjcmlwdGlvbi5yYXAgPSB0cnVlXG4gICAgICAgIHN1YnNjcmlwdGlvbi5ubCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gUHVzaCBwYWlyIHRvIHN1YnNjcmlwdGlvbnNcbiAgICAgIGRlYnVnKCdfcGFyc2VTdWJzY3JpYmU6IHB1c2ggc3Vic2NyaXB0aW9uIGAlc2AgdG8gc3Vic2NyaXB0aW9uJywgc3Vic2NyaXB0aW9uKVxuICAgICAgcGFja2V0LnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pXG4gICAgfVxuICB9XG5cbiAgX3BhcnNlU3ViYWNrICgpIHtcbiAgICBkZWJ1ZygnX3BhcnNlU3ViYWNrJylcbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICAgIHRoaXMucGFja2V0LmdyYW50ZWQgPSBbXVxuXG4gICAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYWNrZXQubGVuZ3RoIDw9IDApIHsgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBzdWJhY2ssIG5vIHBheWxvYWQgc3BlY2lmaWVkJykpIH1cblxuICAgIC8vIFBhcnNlIGdyYW50ZWQgUW9TZXNcbiAgICB3aGlsZSAodGhpcy5fcG9zIDwgdGhpcy5wYWNrZXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjb2RlID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgICAgaWYgKCFjb25zdGFudHMuTVFUVDVfU1VCQUNLX0NPREVTW2NvZGVdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgc3ViYWNrIGNvZGUnKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGUgPiAyICYmIGNvZGUgIT09IDB4ODApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignSW52YWxpZCBzdWJhY2sgUW9TLCBtdXN0IGJlIDAsIDEsIDIgb3IgMTI4JykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFja2V0LmdyYW50ZWQucHVzaChjb2RlKVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVVuc3Vic2NyaWJlICgpIHtcbiAgICBkZWJ1ZygnX3BhcnNlVW5zdWJzY3JpYmUnKVxuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zID0gW11cblxuICAgIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICAgIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gICAgLy8gUHJvcGVydGllcyBtcXR0IDVcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFja2V0Lmxlbmd0aCA8PSAwKSB7IHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdNYWxmb3JtZWQgdW5zdWJzY3JpYmUsIG5vIHBheWxvYWQgc3BlY2lmaWVkJykpIH1cblxuICAgIHdoaWxlICh0aGlzLl9wb3MgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgICAvLyBQYXJzZSB0b3BpY1xuICAgICAgY29uc3QgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAgICAgLy8gUHVzaCB0b3BpYyB0byB1bnN1YnNjcmlwdGlvbnNcbiAgICAgIGRlYnVnKCdfcGFyc2VVbnN1YnNjcmliZTogcHVzaCB0b3BpYyBgJXNgIHRvIHVuc3Vic2NyaXB0aW9ucycsIHRvcGljKVxuICAgICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucy5wdXNoKHRvcGljKVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVVuc3ViYWNrICgpIHtcbiAgICBkZWJ1ZygnX3BhcnNlVW5zdWJhY2snKVxuICAgIGNvbnN0IHBhY2tldCA9IHRoaXMucGFja2V0XG4gICAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIG1lc3NhZ2VJZCcpKVxuXG4gICAgaWYgKCh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gMyB8fFxuICAgICAgdGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDQpICYmIHBhY2tldC5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdNYWxmb3JtZWQgdW5zdWJhY2ssIHBheWxvYWQgbGVuZ3RoIG11c3QgYmUgMicpKVxuICAgIH1cbiAgICBpZiAocGFja2V0Lmxlbmd0aCA8PSAwKSB7IHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdNYWxmb3JtZWQgdW5zdWJhY2ssIG5vIHBheWxvYWQgc3BlY2lmaWVkJykpIH1cblxuICAgIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgICB9XG4gICAgICAvLyBQYXJzZSBncmFudGVkIFFvU2VzXG4gICAgICBwYWNrZXQuZ3JhbnRlZCA9IFtdXG5cbiAgICAgIHdoaWxlICh0aGlzLl9wb3MgPCB0aGlzLnBhY2tldC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKVxuICAgICAgICBpZiAoIWNvbnN0YW50cy5NUVRUNV9VTlNVQkFDS19DT0RFU1tjb2RlXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHVuc3ViYWNrIGNvZGUnKSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhY2tldC5ncmFudGVkLnB1c2goY29kZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwYXJzZSBwYWNrZXRzIGxpa2UgcHViYWNrLCBwdWJyZWMsIHB1YnJlbCwgcHViY29tcFxuICBfcGFyc2VDb25maXJtYXRpb24gKCkge1xuICAgIGRlYnVnKCdfcGFyc2VDb25maXJtYXRpb246IHBhY2tldC5jbWQ6IGAlc2AnLCB0aGlzLnBhY2tldC5jbWQpXG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICAgIHRoaXMuX3BhcnNlTWVzc2FnZUlkKClcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgaWYgKHBhY2tldC5sZW5ndGggPiAyKSB7XG4gICAgICAgIC8vIHJlc3BvbnNlIGNvZGVcbiAgICAgICAgcGFja2V0LnJlYXNvbkNvZGUgPSB0aGlzLl9wYXJzZUJ5dGUoKVxuICAgICAgICBzd2l0Y2ggKHRoaXMucGFja2V0LmNtZCkge1xuICAgICAgICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgICAgICAgY2FzZSAncHVicmVjJzpcbiAgICAgICAgICAgIGlmICghY29uc3RhbnRzLk1RVFQ1X1BVQkFDS19QVUJSRUNfQ09ERVNbcGFja2V0LnJlYXNvbkNvZGVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkICcgKyB0aGlzLnBhY2tldC5jbWQgKyAnIHJlYXNvbiBjb2RlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgICAgICAgY2FzZSAncHViY29tcCc6XG4gICAgICAgICAgICBpZiAoIWNvbnN0YW50cy5NUVRUNV9QVUJSRUxfUFVCQ09NUF9DT0RFU1twYWNrZXQucmVhc29uQ29kZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgJyArIHRoaXMucGFja2V0LmNtZCArICcgcmVhc29uIGNvZGUnKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ19wYXJzZUNvbmZpcm1hdGlvbjogcGFja2V0LnJlYXNvbkNvZGUgYCVkYCcsIHBhY2tldC5yZWFzb25Db2RlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFja2V0LnJlYXNvbkNvZGUgPSAwXG4gICAgICB9XG5cbiAgICAgIGlmIChwYWNrZXQubGVuZ3RoID4gMykge1xuICAgICAgICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcGFyc2UgZGlzY29ubmVjdCBwYWNrZXRcbiAgX3BhcnNlRGlzY29ubmVjdCAoKSB7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgICBkZWJ1ZygnX3BhcnNlRGlzY29ubmVjdCcpXG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgIC8vIHJlc3BvbnNlIGNvZGVcbiAgICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFja2V0LnJlYXNvbkNvZGUgPSB0aGlzLl9wYXJzZUJ5dGUoKVxuICAgICAgICBpZiAoIWNvbnN0YW50cy5NUVRUNV9ESVNDT05ORUNUX0NPREVTW3BhY2tldC5yZWFzb25Db2RlXSkge1xuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgZGlzY29ubmVjdCByZWFzb24gY29kZScpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWNrZXQucmVhc29uQ29kZSA9IDBcbiAgICAgIH1cbiAgICAgIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnX3BhcnNlRGlzY29ubmVjdCByZXN1bHQ6IHRydWUnKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBwYXJzZSBhdXRoIHBhY2tldFxuICBfcGFyc2VBdXRoICgpIHtcbiAgICBkZWJ1ZygnX3BhcnNlQXV0aCcpXG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiAhPT0gNSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgYXV0aCBwYWNrZXQgZm9yIHRoaXMgdmVyc2lvbiBNUVRUJykpXG4gICAgfVxuXG4gICAgLy8gcmVzcG9uc2UgY29kZVxuICAgIHBhY2tldC5yZWFzb25Db2RlID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICBpZiAoIWNvbnN0YW50cy5NUVRUNV9BVVRIX0NPREVTW3BhY2tldC5yZWFzb25Db2RlXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aCByZWFzb24gY29kZScpKVxuICAgIH1cbiAgICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuXG4gICAgZGVidWcoJ19wYXJzZUF1dGg6IHJlc3VsdDogdHJ1ZScpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9wYXJzZU1lc3NhZ2VJZCAoKSB7XG4gICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICAgIHBhY2tldC5tZXNzYWdlSWQgPSB0aGlzLl9wYXJzZU51bSgpXG5cbiAgICBpZiAocGFja2V0Lm1lc3NhZ2VJZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIG1lc3NhZ2VJZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgZGVidWcoJ19wYXJzZU1lc3NhZ2VJZDogcGFja2V0Lm1lc3NhZ2VJZCAlZCcsIHBhY2tldC5tZXNzYWdlSWQpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9wYXJzZVN0cmluZyAobWF5YmVCdWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLl9wYXJzZU51bSgpXG4gICAgY29uc3QgZW5kID0gbGVuZ3RoICsgdGhpcy5fcG9zXG5cbiAgICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9saXN0LnRvU3RyaW5nKCd1dGY4JywgdGhpcy5fcG9zLCBlbmQpXG4gICAgdGhpcy5fcG9zICs9IGxlbmd0aFxuICAgIGRlYnVnKCdfcGFyc2VTdHJpbmc6IHJlc3VsdDogJXMnLCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgX3BhcnNlU3RyaW5nUGFpciAoKSB7XG4gICAgZGVidWcoJ19wYXJzZVN0cmluZ1BhaXInKVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLl9wYXJzZVN0cmluZygpLFxuICAgICAgdmFsdWU6IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICB9XG4gIH1cblxuICBfcGFyc2VCdWZmZXIgKCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX3BhcnNlTnVtKClcbiAgICBjb25zdCBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICAgIGlmIChsZW5ndGggPT09IC0xIHx8IGVuZCA+IHRoaXMuX2xpc3QubGVuZ3RoIHx8IGVuZCA+IHRoaXMucGFja2V0Lmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2xpc3Quc2xpY2UodGhpcy5fcG9zLCBlbmQpXG5cbiAgICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG4gICAgZGVidWcoJ19wYXJzZUJ1ZmZlcjogcmVzdWx0OiAlbycsIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBfcGFyc2VOdW0gKCkge1xuICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCAtIHRoaXMuX3BvcyA8IDIpIHJldHVybiAtMVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbGlzdC5yZWFkVUludDE2QkUodGhpcy5fcG9zKVxuICAgIHRoaXMuX3BvcyArPSAyXG4gICAgZGVidWcoJ19wYXJzZU51bTogcmVzdWx0OiAlcycsIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBfcGFyc2U0Qnl0ZU51bSAoKSB7XG4gICAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIC0gdGhpcy5fcG9zIDwgNCkgcmV0dXJuIC0xXG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9saXN0LnJlYWRVSW50MzJCRSh0aGlzLl9wb3MpXG4gICAgdGhpcy5fcG9zICs9IDRcbiAgICBkZWJ1ZygnX3BhcnNlNEJ5dGVOdW06IHJlc3VsdDogJXMnLCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgX3BhcnNlVmFyQnl0ZU51bSAoZnVsbEluZm9GbGFnKSB7XG4gICAgZGVidWcoJ19wYXJzZVZhckJ5dGVOdW0nKVxuICAgIGNvbnN0IG1heEJ5dGVzID0gNFxuICAgIGxldCBieXRlcyA9IDBcbiAgICBsZXQgbXVsID0gMVxuICAgIGxldCB2YWx1ZSA9IDBcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2VcbiAgICBsZXQgY3VycmVudFxuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wb3MgPyB0aGlzLl9wb3MgOiAwXG5cbiAgICB3aGlsZSAoYnl0ZXMgPCBtYXhCeXRlcyAmJiAocGFkZGluZyArIGJ5dGVzKSA8IHRoaXMuX2xpc3QubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50ID0gdGhpcy5fbGlzdC5yZWFkVUludDgocGFkZGluZyArIGJ5dGVzKyspXG4gICAgICB2YWx1ZSArPSBtdWwgKiAoY3VycmVudCAmIGNvbnN0YW50cy5WQVJCWVRFSU5UX01BU0spXG4gICAgICBtdWwgKj0gMHg4MFxuXG4gICAgICBpZiAoKGN1cnJlbnQgJiBjb25zdGFudHMuVkFSQllURUlOVF9GSU5fTUFTSykgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIDw9IGJ5dGVzKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHQgJiYgYnl0ZXMgPT09IG1heEJ5dGVzICYmIHRoaXMuX2xpc3QubGVuZ3RoID49IGJ5dGVzKSB7XG4gICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHZhcmlhYmxlIGJ5dGUgaW50ZWdlcicpKVxuICAgIH1cblxuICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICB0aGlzLl9wb3MgKz0gYnl0ZXNcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoZnVsbEluZm9GbGFnKSB7XG4gICAgICAgIHJlc3VsdCA9IHsgYnl0ZXMsIHZhbHVlIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlXG4gICAgfVxuXG4gICAgZGVidWcoJ19wYXJzZVZhckJ5dGVOdW06IHJlc3VsdDogJW8nLCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgX3BhcnNlQnl0ZSAoKSB7XG4gICAgbGV0IHJlc3VsdFxuICAgIGlmICh0aGlzLl9wb3MgPCB0aGlzLl9saXN0Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKVxuICAgICAgdGhpcy5fcG9zKytcbiAgICB9XG4gICAgZGVidWcoJ19wYXJzZUJ5dGU6IHJlc3VsdDogJW8nLCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgX3BhcnNlQnlUeXBlICh0eXBlKSB7XG4gICAgZGVidWcoJ19wYXJzZUJ5VHlwZTogdHlwZTogJXMnLCB0eXBlKVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYnl0ZSc6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQnl0ZSgpICE9PSAwXG4gICAgICB9XG4gICAgICBjYXNlICdpbnQ4Jzoge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VCeXRlKClcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2ludDE2Jzoge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VOdW0oKVxuICAgICAgfVxuICAgICAgY2FzZSAnaW50MzInOiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZTRCeXRlTnVtKClcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3Zhcic6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVmFyQnl0ZU51bSgpXG4gICAgICB9XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgICB9XG4gICAgICBjYXNlICdwYWlyJzoge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VTdHJpbmdQYWlyKClcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcGFyc2VQcm9wZXJ0aWVzICgpIHtcbiAgICBkZWJ1ZygnX3BhcnNlUHJvcGVydGllcycpXG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKClcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX3Bvc1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuZ3RoXG4gICAgY29uc3QgcmVzdWx0ID0ge31cbiAgICB3aGlsZSAodGhpcy5fcG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcHJvcGVydHkgY29kZSB0eXBlJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IGNvbnN0YW50cy5wcm9wZXJ0aWVzQ29kZXNbdHlwZV1cbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdVbmtub3duIHByb3BlcnR5JykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLy8gdXNlciBwcm9wZXJ0aWVzIHByb2Nlc3NcbiAgICAgIGlmIChuYW1lID09PSAndXNlclByb3BlcnRpZXMnKSB7XG4gICAgICAgIGlmICghcmVzdWx0W25hbWVdKSB7XG4gICAgICAgICAgcmVzdWx0W25hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyUHJvcGVydHkgPSB0aGlzLl9wYXJzZUJ5VHlwZShjb25zdGFudHMucHJvcGVydGllc1R5cGVzW25hbWVdKVxuICAgICAgICBpZiAocmVzdWx0W25hbWVdW2N1cnJlbnRVc2VyUHJvcGVydHkubmFtZV0pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRbbmFtZV1bY3VycmVudFVzZXJQcm9wZXJ0eS5uYW1lXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXVtjdXJyZW50VXNlclByb3BlcnR5Lm5hbWVdLnB1c2goY3VycmVudFVzZXJQcm9wZXJ0eS52YWx1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gcmVzdWx0W25hbWVdW2N1cnJlbnRVc2VyUHJvcGVydHkubmFtZV1cbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXVtjdXJyZW50VXNlclByb3BlcnR5Lm5hbWVdID0gW2N1cnJlbnRWYWx1ZV1cbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXVtjdXJyZW50VXNlclByb3BlcnR5Lm5hbWVdLnB1c2goY3VycmVudFVzZXJQcm9wZXJ0eS52YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W25hbWVdW2N1cnJlbnRVc2VyUHJvcGVydHkubmFtZV0gPSBjdXJyZW50VXNlclByb3BlcnR5LnZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHRbbmFtZV0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W25hbWVdKSkge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXS5wdXNoKHRoaXMuX3BhcnNlQnlUeXBlKGNvbnN0YW50cy5wcm9wZXJ0aWVzVHlwZXNbbmFtZV0pKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IFtyZXN1bHRbbmFtZV1dXG4gICAgICAgICAgcmVzdWx0W25hbWVdLnB1c2godGhpcy5fcGFyc2VCeVR5cGUoY29uc3RhbnRzLnByb3BlcnRpZXNUeXBlc1tuYW1lXSkpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IHRoaXMuX3BhcnNlQnlUeXBlKGNvbnN0YW50cy5wcm9wZXJ0aWVzVHlwZXNbbmFtZV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIF9uZXdQYWNrZXQgKCkge1xuICAgIGRlYnVnKCdfbmV3UGFja2V0JylcbiAgICBpZiAodGhpcy5wYWNrZXQpIHtcbiAgICAgIHRoaXMuX2xpc3QuY29uc3VtZSh0aGlzLnBhY2tldC5sZW5ndGgpXG4gICAgICBkZWJ1ZygnX25ld1BhY2tldDogcGFyc2VyIGVtaXQgcGFja2V0OiBwYWNrZXQuY21kOiAlcywgcGFja2V0LnBheWxvYWQ6ICVzLCBwYWNrZXQubGVuZ3RoOiAlZCcsIHRoaXMucGFja2V0LmNtZCwgdGhpcy5wYWNrZXQucGF5bG9hZCwgdGhpcy5wYWNrZXQubGVuZ3RoKVxuICAgICAgdGhpcy5lbWl0KCdwYWNrZXQnLCB0aGlzLnBhY2tldClcbiAgICB9XG4gICAgZGVidWcoJ19uZXdQYWNrZXQ6IG5ldyBwYWNrZXQnKVxuICAgIHRoaXMucGFja2V0ID0gbmV3IFBhY2tldCgpXG5cbiAgICB0aGlzLl9wb3MgPSAwXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX2VtaXRFcnJvciAoZXJyKSB7XG4gICAgZGVidWcoJ19lbWl0RXJyb3InLCBlcnIpXG4gICAgdGhpcy5lcnJvciA9IGVyclxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mqtt-packet/writeToStream.js":
/*!***************************************************!*\
  !*** ./node_modules/mqtt-packet/writeToStream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const protocol = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/mqtt-packet/constants.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst empty = Buffer.allocUnsafe(0)\nconst zeroBuf = Buffer.from([0])\nconst numbers = __webpack_require__(/*! ./numbers */ \"(ssr)/./node_modules/mqtt-packet/numbers.js\")\nconst nextTick = (__webpack_require__(/*! process-nextick-args */ \"(ssr)/./node_modules/process-nextick-args/index.js\").nextTick)\nconst debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")('mqtt-packet:writeToStream')\n\nconst numCache = numbers.cache\nconst generateNumber = numbers.generateNumber\nconst generateCache = numbers.generateCache\nconst genBufVariableByteInt = numbers.genBufVariableByteInt\nconst generate4ByteBuffer = numbers.generate4ByteBuffer\nlet writeNumber = writeNumberCached\nlet toGenerate = true\n\nfunction generate (packet, stream, opts) {\n  debug('generate called')\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n  debug('generate: packet.cmd: %s', packet.cmd)\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts)\n    case 'connack':\n      return connack(packet, stream, opts)\n    case 'publish':\n      return publish(packet, stream, opts)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts)\n    case 'subscribe':\n      return subscribe(packet, stream, opts)\n    case 'suback':\n      return suback(packet, stream, opts)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts)\n    case 'unsuback':\n      return unsuback(packet, stream, opts)\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts)\n    case 'disconnect':\n      return disconnect(packet, stream, opts)\n    case 'auth':\n      return auth(packet, stream, opts)\n    default:\n      stream.destroy(new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get () {\n    return writeNumber === writeNumberCached\n  },\n  set (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (packet, stream, opts) {\n  const settings = packet || {}\n  const protocolId = settings.protocolId || 'MQTT'\n  let protocolVersion = settings.protocolVersion || 4\n  const will = settings.will\n  let clean = settings.clean\n  const keepalive = settings.keepalive || 0\n  const clientId = settings.clientId || ''\n  const username = settings.username\n  const password = settings.password\n  /* mqtt5 new oprions */\n  const properties = settings.properties\n\n  if (clean === undefined) clean = true\n\n  let length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.destroy(new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.destroy(new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.destroy(new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.destroy(new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.destroy(new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  let propertiesData\n  let willProperties\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.destroy(new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.destroy(new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    length += 2 // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload)\n        } else {\n          length += will.payload.length\n        }\n      } else {\n        stream.destroy(new Error('Invalid will payload'))\n        return false\n      }\n    }\n    // will properties\n    willProperties = {}\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties)\n      if (!willProperties) { return false }\n      length += willProperties.length\n    }\n  }\n\n  // Username\n  let providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.destroy(new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.destroy(new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.destroy(new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128\n  }\n\n  stream.write(\n    protocolVersion === 131\n      ? protocol.VERSION131\n      : protocolVersion === 132\n        ? protocol.VERSION132\n        : protocolVersion === 4\n          ? protocol.VERSION4\n          : protocolVersion === 5\n            ? protocol.VERSION5\n            : protocol.VERSION3\n  )\n\n  // Connect flags\n  let flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write()\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write()\n    }\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode\n  const properties = settings.properties\n  let length = 2 // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.destroy(new Error('Invalid return code'))\n    return false\n  }\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  // length\n  writeVarByteInt(stream, length)\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  stream.write(Buffer.from([rc]))\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction publish (packet, stream, opts) {\n  debug('publish: packet: %o', packet)\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const qos = settings.qos || 0\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0\n  const topic = settings.topic\n  const payload = settings.payload || empty\n  const id = settings.messageId\n  const properties = settings.properties\n\n  let length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.destroy(new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.destroy(new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeVarByteInt(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload)\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const type = settings.cmd || 'puback'\n  const id = settings.messageId\n  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  let qos = 0\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 3 : 2\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.destroy(new Error('Invalid messageId'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n      if (!propertiesData) { return false }\n      length += propertiesData.length\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length === 3 is only true of version === 5 and no properties; therefore if reasonCode === 0 we are allowed to skip both bytes - but if we write the reason code we also have to write property length [MQTT-3.4.2-1].\n  if (length === 3) length += reasonCode !== 0 ? 1 : -1\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // reason code in header - but only if it couldn't be omitted - indicated by length !== 2.\n  if (version === 5 && length !== 2) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properties mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  } else {\n    if (length === 4) {\n      // we have no properties but have written a reason code - so we need to indicate empty properties by filling in a zero.\n      stream.write(Buffer.from([0]))\n    }\n  }\n  return true\n}\n\nfunction subscribe (packet, stream, opts) {\n  debug('subscribe: packet: ')\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const id = settings.messageId\n  const subs = settings.subscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.destroy(new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic\n      const iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.destroy(new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.destroy(new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false\n        if (typeof nl !== 'boolean') {\n          stream.destroy(new Error('Invalid subscriptions - invalid No Local'))\n          return false\n        }\n        const rap = subs[i].rap || false\n        if (typeof rap !== 'boolean') {\n          stream.destroy(new Error('Invalid subscriptions - invalid Retain as Published'))\n          return false\n        }\n        const rh = subs[i].rh || 0\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.destroy(new Error('Invalid subscriptions - invalid Retain Handling'))\n          return false\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.destroy(new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  let result = true\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic\n    const jqos = sub.qos\n    const jnl = +sub.nl\n    const jrap = +sub.rap\n    const jrh = sub.rh\n    let joptions\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]))\n  }\n\n  return result\n}\n\nfunction suback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const granted = settings.granted\n  const properties = settings.properties\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.destroy(new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.destroy(new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.destroy(new Error('Invalid qos vector'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const unsubs = settings.unsubscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.destroy(new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.destroy(new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.destroy(new Error('Invalid unsubscriptions'))\n    return false\n  }\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // Unsubs\n  let result = true\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction unsuback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const granted = settings.granted\n  const properties = settings.properties\n  const type = settings.cmd\n  const qos = 0\n\n  let length = 2\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.destroy(new Error('Invalid messageId'))\n    return false\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.destroy(new Error('Invalid qos vector'))\n          return false\n        }\n        length += 1\n      }\n    } else {\n      stream.destroy(new Error('Invalid qos vector'))\n      return false\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted))\n  }\n  return true\n}\n\nfunction emptyPacket (packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd])\n}\n\nfunction disconnect (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return true\n}\n\nfunction auth (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  if (version !== 5) stream.destroy(new Error('Invalid mqtt version for auth packet'))\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n  if (!propertiesData) { return false }\n  length += propertiesData.length\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]))\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {}\nfunction writeVarByteInt (stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.destroy(new Error(`Invalid variable byte integer: ${num}`))\n    return false\n  }\n\n  let buffer = varByteIntCache[num]\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num)\n    if (num < 16384) varByteIntCache[num] = buffer\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer)\n  return stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  const strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  debug('writeString: %s', string)\n  return stream.write(string, 'utf8')\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair (stream, name, value) {\n  writeString(stream, name)\n  writeString(stream, value)\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  debug('writeNumberCached: number: %d', number)\n  debug('writeNumberCached: %o', numCache[number])\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  const generatedNumber = generateNumber(number)\n  debug('writeNumberGenerated: %o', generatedNumber)\n  return stream.write(generatedNumber)\n}\nfunction write4ByteNumber (stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number)\n  debug('write4ByteNumber: %o', generated4ByteBuffer)\n  return stream.write(generated4ByteBuffer)\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction getProperties (stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write () {\n        writeProperties(stream, {}, 0)\n      }\n    }\n  }\n  let propertiesLength = 0\n  function getLengthProperty (name, value) {\n    const type = protocol.propertiesTypes[name]\n    let length = 0\n    switch (type) {\n      case 'byte': {\n        if (typeof value !== 'boolean') {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'int8': {\n        if (typeof value !== 'number' || value < 0 || value > 0xff) {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'binary': {\n        if (value && value === null) {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(value) + 2\n        break\n      }\n      case 'int16': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2\n        break\n      }\n      case 'int32': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 4\n        break\n      }\n      case 'var': {\n        // var byte integer is max 24 bits packed in 32 bits\n        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))\n        break\n      }\n      case 'string': {\n        if (typeof value !== 'string') {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2 + Buffer.byteLength(value.toString())\n        break\n      }\n      case 'pair': {\n        if (typeof value !== 'object') {\n          stream.destroy(new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n          const currentValue = value[name]\n          if (Array.isArray(currentValue)) {\n            result += currentValue.reduce((currentLength, value) => {\n              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())\n              return currentLength\n            }, 0)\n          } else {\n            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())\n          }\n          return result\n        }, 0)\n        break\n      }\n      default: {\n        stream.destroy(new Error(`Invalid property ${name}: ${value}`))\n        return false\n      }\n    }\n    return length\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0\n      let propValueLength = 0\n      const propValue = properties[propName]\n      if (propValue === undefined) {\n        continue\n      } else if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex])\n          if (!propValueLength) { return false }\n          propLength += propValueLength\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue)\n        if (!propValueLength) { return false }\n        propLength = propValueLength\n      }\n      if (!propLength) return false\n      propertiesLength += propLength\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))\n\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write () {\n      writeProperties(stream, properties, propertiesLength)\n    }\n  }\n}\n\nfunction getPropertiesByMaximumPacketSize (stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties']\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0\n\n  let propertiesData = getProperties(stream, properties)\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift()\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp]\n        propertiesData = getProperties(stream, properties)\n      } else {\n        return false\n      }\n    }\n  }\n  return propertiesData\n}\n\nfunction writeProperty (stream, propName, value) {\n  const type = protocol.propertiesTypes[propName]\n  switch (type) {\n    case 'byte': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([+value]))\n      break\n    }\n    case 'int8': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([value]))\n      break\n    }\n    case 'binary': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeStringOrBuffer(stream, value)\n      break\n    }\n    case 'int16': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeNumber(stream, value)\n      break\n    }\n    case 'int32': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      write4ByteNumber(stream, value)\n      break\n    }\n    case 'var': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeVarByteInt(stream, value)\n      break\n    }\n    case 'string': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeString(stream, value)\n      break\n    }\n    case 'pair': {\n      Object.getOwnPropertyNames(value).forEach(name => {\n        const currentValue = value[name]\n        if (Array.isArray(currentValue)) {\n          currentValue.forEach(value => {\n            stream.write(Buffer.from([protocol.properties[propName]]))\n            writeStringPair(stream, name.toString(), value.toString())\n          })\n        } else {\n          stream.write(Buffer.from([protocol.properties[propName]]))\n          writeStringPair(stream, name.toString(), currentValue.toString())\n        }\n      })\n      break\n    }\n    default: {\n      stream.destroy(new Error(`Invalid property ${propName} value: ${value}`))\n      return false\n    }\n  }\n}\n\nfunction writeProperties (stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength)\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] != null) {\n      const value = properties[propName]\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex])\n        }\n      } else {\n        writeProperty(stream, propName, value)\n      }\n    }\n  }\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvd3JpdGVUb1N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRUFBYTtBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ25DO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4REFBVztBQUNuQyxpQkFBaUIsZ0hBQXdDO0FBQ3pELGNBQWMsbUJBQU8sQ0FBQyxzREFBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxJQUFJO0FBQ25FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLLElBQUksTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLLElBQUksTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLLElBQUksTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLLElBQUksTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLLElBQUksTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUssSUFBSSxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUssSUFBSSxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUssSUFBSSxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSyxJQUFJLE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLFNBQVMsTUFBTTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sZC1zdG9yYWdlLXN5c3RlbS8uL25vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC93cml0ZVRvU3RyZWFtLmpzPzBhYTkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJvdG9jb2wgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IGVtcHR5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG5jb25zdCB6ZXJvQnVmID0gQnVmZmVyLmZyb20oWzBdKVxuY29uc3QgbnVtYmVycyA9IHJlcXVpcmUoJy4vbnVtYmVycycpXG5jb25zdCBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJykubmV4dFRpY2tcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbXF0dC1wYWNrZXQ6d3JpdGVUb1N0cmVhbScpXG5cbmNvbnN0IG51bUNhY2hlID0gbnVtYmVycy5jYWNoZVxuY29uc3QgZ2VuZXJhdGVOdW1iZXIgPSBudW1iZXJzLmdlbmVyYXRlTnVtYmVyXG5jb25zdCBnZW5lcmF0ZUNhY2hlID0gbnVtYmVycy5nZW5lcmF0ZUNhY2hlXG5jb25zdCBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQgPSBudW1iZXJzLmdlbkJ1ZlZhcmlhYmxlQnl0ZUludFxuY29uc3QgZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciA9IG51bWJlcnMuZ2VuZXJhdGU0Qnl0ZUJ1ZmZlclxubGV0IHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJDYWNoZWRcbmxldCB0b0dlbmVyYXRlID0gdHJ1ZVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgZGVidWcoJ2dlbmVyYXRlIGNhbGxlZCcpXG4gIGlmIChzdHJlYW0uY29yaykge1xuICAgIHN0cmVhbS5jb3JrKClcbiAgICBuZXh0VGljayh1bmNvcmssIHN0cmVhbSlcbiAgfVxuXG4gIGlmICh0b0dlbmVyYXRlKSB7XG4gICAgdG9HZW5lcmF0ZSA9IGZhbHNlXG4gICAgZ2VuZXJhdGVDYWNoZSgpXG4gIH1cbiAgZGVidWcoJ2dlbmVyYXRlOiBwYWNrZXQuY21kOiAlcycsIHBhY2tldC5jbWQpXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGNvbm5lY3QocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAnY29ubmFjayc6XG4gICAgICByZXR1cm4gY29ubmFjayhwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgIHJldHVybiBwdWJsaXNoKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgY2FzZSAncHVicmVjJzpcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbihwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgcmV0dXJuIHN1YnNjcmliZShwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdzdWJhY2snOlxuICAgICAgcmV0dXJuIHN1YmFjayhwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmUocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgcmV0dXJuIHVuc3ViYWNrKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICAgIHJldHVybiBlbXB0eVBhY2tldChwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgIHJldHVybiBkaXNjb25uZWN0KHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ2F1dGgnOlxuICAgICAgcmV0dXJuIGF1dGgocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignVW5rbm93biBjb21tYW5kJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuLyoqXG4gKiBDb250cm9scyBudW1iZXJzIGNhY2hlLlxuICogU2V0IHRvIFwiZmFsc2VcIiB0byBhbGxvY2F0ZSBidWZmZXJzIG9uLXRoZS1mbGlnaHQgaW5zdGVhZCBvZiBwcmUtZ2VuZXJhdGVkIGNhY2hlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZW5lcmF0ZSwgJ2NhY2hlTnVtYmVycycsIHtcbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gd3JpdGVOdW1iZXIgPT09IHdyaXRlTnVtYmVyQ2FjaGVkXG4gIH0sXG4gIHNldCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghbnVtQ2FjaGUgfHwgT2JqZWN0LmtleXMobnVtQ2FjaGUpLmxlbmd0aCA9PT0gMCkgdG9HZW5lcmF0ZSA9IHRydWVcbiAgICAgIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJDYWNoZWRcbiAgICB9IGVsc2Uge1xuICAgICAgdG9HZW5lcmF0ZSA9IGZhbHNlXG4gICAgICB3cml0ZU51bWJlciA9IHdyaXRlTnVtYmVyR2VuZXJhdGVkXG4gICAgfVxuICB9XG59KVxuXG5mdW5jdGlvbiB1bmNvcmsgKHN0cmVhbSkge1xuICBzdHJlYW0udW5jb3JrKClcbn1cblxuZnVuY3Rpb24gY29ubmVjdCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgY29uc3QgcHJvdG9jb2xJZCA9IHNldHRpbmdzLnByb3RvY29sSWQgfHwgJ01RVFQnXG4gIGxldCBwcm90b2NvbFZlcnNpb24gPSBzZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gfHwgNFxuICBjb25zdCB3aWxsID0gc2V0dGluZ3Mud2lsbFxuICBsZXQgY2xlYW4gPSBzZXR0aW5ncy5jbGVhblxuICBjb25zdCBrZWVwYWxpdmUgPSBzZXR0aW5ncy5rZWVwYWxpdmUgfHwgMFxuICBjb25zdCBjbGllbnRJZCA9IHNldHRpbmdzLmNsaWVudElkIHx8ICcnXG4gIGNvbnN0IHVzZXJuYW1lID0gc2V0dGluZ3MudXNlcm5hbWVcbiAgY29uc3QgcGFzc3dvcmQgPSBzZXR0aW5ncy5wYXNzd29yZFxuICAvKiBtcXR0NSBuZXcgb3ByaW9ucyAqL1xuICBjb25zdCBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIGlmIChjbGVhbiA9PT0gdW5kZWZpbmVkKSBjbGVhbiA9IHRydWVcblxuICBsZXQgbGVuZ3RoID0gMFxuXG4gIC8vIE11c3QgYmUgYSBzdHJpbmcgYW5kIG5vbi1mYWxzeVxuICBpZiAoIXByb3RvY29sSWQgfHxcbiAgICAgKHR5cGVvZiBwcm90b2NvbElkICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKHByb3RvY29sSWQpKSkge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbElkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gcHJvdG9jb2xJZC5sZW5ndGggKyAyXG5cbiAgLy8gTXVzdCBiZSAzIG9yIDQgb3IgNVxuICBpZiAocHJvdG9jb2xWZXJzaW9uICE9PSAzICYmIHByb3RvY29sVmVyc2lvbiAhPT0gNCAmJiBwcm90b2NvbFZlcnNpb24gIT09IDUpIHtcbiAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDFcblxuICAvLyBDbGllbnRJZCBtaWdodCBiZSBvbWl0dGVkIGluIDMuMS4xIGFuZCA1LCBidXQgb25seSBpZiBjbGVhblNlc3Npb24gaXMgc2V0IHRvIDFcbiAgaWYgKCh0eXBlb2YgY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihjbGllbnRJZCkpICYmXG4gICAgIChjbGllbnRJZCB8fCBwcm90b2NvbFZlcnNpb24gPj0gNCkgJiYgKGNsaWVudElkIHx8IGNsZWFuKSkge1xuICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChjbGllbnRJZCkgKyAyXG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb3RvY29sVmVyc2lvbiA8IDQpIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignY2xpZW50SWQgbXVzdCBiZSBzdXBwbGllZCBiZWZvcmUgMy4xLjEnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoKGNsZWFuICogMSkgPT09IDApIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignY2xpZW50SWQgbXVzdCBiZSBnaXZlbiBpZiBjbGVhblNlc3Npb24gc2V0IHRvIDAnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIE11c3QgYmUgYSB0d28gYnl0ZSBudW1iZXJcbiAgaWYgKHR5cGVvZiBrZWVwYWxpdmUgIT09ICdudW1iZXInIHx8XG4gICAgICBrZWVwYWxpdmUgPCAwIHx8XG4gICAgICBrZWVwYWxpdmUgPiA2NTUzNSB8fFxuICAgICAga2VlcGFsaXZlICUgMSAhPT0gMCkge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBrZWVwYWxpdmUnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAyXG5cbiAgLy8gQ29ubmVjdCBmbGFnc1xuICBsZW5ndGggKz0gMVxuXG4gIGxldCBwcm9wZXJ0aWVzRGF0YVxuICBsZXQgd2lsbFByb3BlcnRpZXNcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBJZiB3aWxsIGV4aXN0cy4uLlxuICBpZiAod2lsbCkge1xuICAgIC8vIEl0IG11c3QgYmUgYW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiB3aWxsICE9PSAnb2JqZWN0Jykge1xuICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIHdpbGwnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBJdCBtdXN0IGhhdmUgdG9waWMgdHlwZW9mIHN0cmluZ1xuICAgIGlmICghd2lsbC50b3BpYyB8fCB0eXBlb2Ygd2lsbC50b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCB3aWxsIHRvcGljJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHdpbGwudG9waWMpICsgMlxuICAgIH1cblxuICAgIC8vIFBheWxvYWRcbiAgICBsZW5ndGggKz0gMiAvLyBwYXlsb2FkIGxlbmd0aFxuICAgIGlmICh3aWxsLnBheWxvYWQpIHtcbiAgICAgIGlmICh3aWxsLnBheWxvYWQubGVuZ3RoID49IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWxsLnBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHdpbGwucGF5bG9hZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggKz0gd2lsbC5wYXlsb2FkLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCBwYXlsb2FkJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB3aWxsIHByb3BlcnRpZXNcbiAgICB3aWxsUHJvcGVydGllcyA9IHt9XG4gICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgd2lsbFByb3BlcnRpZXMgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgd2lsbC5wcm9wZXJ0aWVzKVxuICAgICAgaWYgKCF3aWxsUHJvcGVydGllcykgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgbGVuZ3RoICs9IHdpbGxQcm9wZXJ0aWVzLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXJuYW1lXG4gIGxldCBwcm92aWRlZFVzZXJuYW1lID0gZmFsc2VcbiAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICBpZiAoaXNTdHJpbmdPckJ1ZmZlcih1c2VybmFtZSkpIHtcbiAgICAgIHByb3ZpZGVkVXNlcm5hbWUgPSB0cnVlXG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodXNlcm5hbWUpICsgMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgdXNlcm5hbWUnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhc3N3b3JkXG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgaWYgKCFwcm92aWRlZFVzZXJuYW1lKSB7XG4gICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ1VzZXJuYW1lIGlzIHJlcXVpcmVkIHRvIHVzZSBwYXNzd29yZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nT3JCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgICBsZW5ndGggKz0gYnl0ZUxlbmd0aChwYXNzd29yZCkgKyAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBwYXNzd29yZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgaGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5DT05ORUNUX0hFQURFUilcblxuICAvLyBHZW5lcmF0ZSBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIEdlbmVyYXRlIHByb3RvY29sIElEXG4gIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCBwcm90b2NvbElkKVxuXG4gIGlmIChzZXR0aW5ncy5icmlkZ2VNb2RlKSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uICs9IDEyOFxuICB9XG5cbiAgc3RyZWFtLndyaXRlKFxuICAgIHByb3RvY29sVmVyc2lvbiA9PT0gMTMxXG4gICAgICA/IHByb3RvY29sLlZFUlNJT04xMzFcbiAgICAgIDogcHJvdG9jb2xWZXJzaW9uID09PSAxMzJcbiAgICAgICAgPyBwcm90b2NvbC5WRVJTSU9OMTMyXG4gICAgICAgIDogcHJvdG9jb2xWZXJzaW9uID09PSA0XG4gICAgICAgICAgPyBwcm90b2NvbC5WRVJTSU9ONFxuICAgICAgICAgIDogcHJvdG9jb2xWZXJzaW9uID09PSA1XG4gICAgICAgICAgICA/IHByb3RvY29sLlZFUlNJT041XG4gICAgICAgICAgICA6IHByb3RvY29sLlZFUlNJT04zXG4gIClcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIGxldCBmbGFncyA9IDBcbiAgZmxhZ3MgfD0gKHVzZXJuYW1lICE9IG51bGwpID8gcHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHBhc3N3b3JkICE9IG51bGwpID8gcHJvdG9jb2wuUEFTU1dPUkRfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5yZXRhaW4pID8gcHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5xb3MpID8gd2lsbC5xb3MgPDwgcHJvdG9jb2wuV0lMTF9RT1NfU0hJRlQgOiAwXG4gIGZsYWdzIHw9IHdpbGwgPyBwcm90b2NvbC5XSUxMX0ZMQUdfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gY2xlYW4gPyBwcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgOiAwXG5cbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtmbGFnc10pKVxuXG4gIC8vIEtlZXBhbGl2ZVxuICB3cml0ZU51bWJlcihzdHJlYW0sIGtlZXBhbGl2ZSlcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBDbGllbnQgSURcbiAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIGNsaWVudElkKVxuXG4gIC8vIFdpbGxcbiAgaWYgKHdpbGwpIHtcbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICB3aWxsUHJvcGVydGllcy53cml0ZSgpXG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgd2lsbC50b3BpYylcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgd2lsbC5wYXlsb2FkKVxuICB9XG5cbiAgLy8gVXNlcm5hbWUgYW5kIHBhc3N3b3JkXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHVzZXJuYW1lKVxuICB9XG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHBhc3N3b3JkKVxuICB9XG4gIC8vIFRoaXMgaXMgYSBzbWFsbCBwYWNrZXQgdGhhdCBoYXBwZW5zIG9ubHkgb25jZSBvbiBhIHN0cmVhbVxuICAvLyBXZSBhc3N1bWUgdGhlIHN0cmVhbSBpcyBhbHdheXMgZnJlZSB0byByZWNlaXZlIG1vcmUgZGF0YSBhZnRlciB0aGlzXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbm5hY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIGNvbnN0IHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIGNvbnN0IHJjID0gdmVyc2lvbiA9PT0gNSA/IHNldHRpbmdzLnJlYXNvbkNvZGUgOiBzZXR0aW5ncy5yZXR1cm5Db2RlXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG4gIGxldCBsZW5ndGggPSAyIC8vIGxlbmd0aCBvZiByYyBhbmQgc2Vzc2lvbkhlYWRlclxuXG4gIC8vIENoZWNrIHJldHVybiBjb2RlXG4gIGlmICh0eXBlb2YgcmMgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIHJldHVybiBjb2RlJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gbXF0dDUgcHJvcGVydGllc1xuICBsZXQgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBpZiAoIXByb3BlcnRpZXNEYXRhKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkNPTk5BQ0tfSEVBREVSKVxuICAvLyBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuICBzdHJlYW0ud3JpdGUoc2V0dGluZ3Muc2Vzc2lvblByZXNlbnQgPyBwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgOiB6ZXJvQnVmKVxuXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmNdKSlcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcHVibGlzaCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgZGVidWcoJ3B1Ymxpc2g6IHBhY2tldDogJW8nLCBwYWNrZXQpXG4gIGNvbnN0IHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIGNvbnN0IHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIGNvbnN0IHFvcyA9IHNldHRpbmdzLnFvcyB8fCAwXG4gIGNvbnN0IHJldGFpbiA9IHNldHRpbmdzLnJldGFpbiA/IHByb3RvY29sLlJFVEFJTl9NQVNLIDogMFxuICBjb25zdCB0b3BpYyA9IHNldHRpbmdzLnRvcGljXG4gIGNvbnN0IHBheWxvYWQgPSBzZXR0aW5ncy5wYXlsb2FkIHx8IGVtcHR5XG4gIGNvbnN0IGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG5cbiAgbGV0IGxlbmd0aCA9IDBcblxuICAvLyBUb3BpYyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBCdWZmZXJcbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0b3BpYykgKyAyXG4gIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3BpYykpIGxlbmd0aCArPSB0b3BpYy5sZW5ndGggKyAyXG4gIGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCB0b3BpYycpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gR2V0IHRoZSBwYXlsb2FkIGxlbmd0aFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSkgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHBheWxvYWQpXG4gIGVsc2UgbGVuZ3RoICs9IHBheWxvYWQubGVuZ3RoXG5cbiAgLy8gTWVzc2FnZSBJRCBtdXN0IGEgbnVtYmVyIGlmIHFvcyA+IDBcbiAgaWYgKHFvcyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHFvcykgbGVuZ3RoICs9IDJcblxuICAvLyBtcXR0NSBwcm9wZXJ0aWVzXG4gIGxldCBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlBVQkxJU0hfSEVBREVSW3Fvc11bc2V0dGluZ3MuZHVwID8gMSA6IDBdW3JldGFpbiA/IDEgOiAwXSlcblxuICAvLyBSZW1haW5pbmcgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBUb3BpY1xuICB3cml0ZU51bWJlcihzdHJlYW0sIGJ5dGVMZW5ndGgodG9waWMpKVxuICBzdHJlYW0ud3JpdGUodG9waWMpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICBpZiAocW9zID4gMCkgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG5cbiAgLy8gUGF5bG9hZFxuICBkZWJ1ZygncHVibGlzaDogcGF5bG9hZDogJW8nLCBwYXlsb2FkKVxuICByZXR1cm4gc3RyZWFtLndyaXRlKHBheWxvYWQpXG59XG5cbi8qIFB1YmFjaywgcHVicmVjLCBwdWJyZWwgYW5kIHB1YmNvbXAgKi9cbmZ1bmN0aW9uIGNvbmZpcm1hdGlvbiAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgY29uc3QgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgY29uc3Qgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgY29uc3QgdHlwZSA9IHNldHRpbmdzLmNtZCB8fCAncHViYWNrJ1xuICBjb25zdCBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICBjb25zdCBkdXAgPSAoc2V0dGluZ3MuZHVwICYmIHR5cGUgPT09ICdwdWJyZWwnKSA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICBsZXQgcW9zID0gMFxuICBjb25zdCByZWFzb25Db2RlID0gc2V0dGluZ3MucmVhc29uQ29kZVxuICBjb25zdCBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICBsZXQgbGVuZ3RoID0gdmVyc2lvbiA9PT0gNSA/IDMgOiAyXG5cbiAgaWYgKHR5cGUgPT09ICdwdWJyZWwnKSBxb3MgPSAxXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgbGV0IHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIC8vIENvbmZpcm0gc2hvdWxkIG5vdCBhZGQgZW1wdHkgcHJvcGVydHkgbGVuZ3RoIHdpdGggbm8gcHJvcGVydGllcyAocmZjIDMuNC4yLjIuMSlcbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICAgICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQUNLU1t0eXBlXVtxb3NdW2R1cF1bMF0pXG5cbiAgLy8gTGVuZ3RoID09PSAzIGlzIG9ubHkgdHJ1ZSBvZiB2ZXJzaW9uID09PSA1IGFuZCBubyBwcm9wZXJ0aWVzOyB0aGVyZWZvcmUgaWYgcmVhc29uQ29kZSA9PT0gMCB3ZSBhcmUgYWxsb3dlZCB0byBza2lwIGJvdGggYnl0ZXMgLSBidXQgaWYgd2Ugd3JpdGUgdGhlIHJlYXNvbiBjb2RlIHdlIGFsc28gaGF2ZSB0byB3cml0ZSBwcm9wZXJ0eSBsZW5ndGggW01RVFQtMy40LjItMV0uXG4gIGlmIChsZW5ndGggPT09IDMpIGxlbmd0aCArPSByZWFzb25Db2RlICE9PSAwID8gMSA6IC0xXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcmVhc29uIGNvZGUgaW4gaGVhZGVyIC0gYnV0IG9ubHkgaWYgaXQgY291bGRuJ3QgYmUgb21pdHRlZCAtIGluZGljYXRlZCBieSBsZW5ndGggIT09IDIuXG4gIGlmICh2ZXJzaW9uID09PSA1ICYmIGxlbmd0aCAhPT0gMikge1xuICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmVhc29uQ29kZV0pKVxuICB9XG5cbiAgLy8gcHJvcGVydGllcyBtcXR0IDVcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9PSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9IGVsc2Uge1xuICAgIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAgIC8vIHdlIGhhdmUgbm8gcHJvcGVydGllcyBidXQgaGF2ZSB3cml0dGVuIGEgcmVhc29uIGNvZGUgLSBzbyB3ZSBuZWVkIHRvIGluZGljYXRlIGVtcHR5IHByb3BlcnRpZXMgYnkgZmlsbGluZyBpbiBhIHplcm8uXG4gICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oWzBdKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICBkZWJ1Zygnc3Vic2NyaWJlOiBwYWNrZXQ6ICcpXG4gIGNvbnN0IHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIGNvbnN0IHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIGNvbnN0IGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICBjb25zdCBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICBjb25zdCBzdWJzID0gc2V0dGluZ3Muc3Vic2NyaXB0aW9uc1xuICBjb25zdCBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIGxldCBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAyXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBsZXQgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBpZiAoIXByb3BlcnRpZXNEYXRhKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gQ2hlY2sgc3Vic2NyaXB0aW9uc1xuICBpZiAodHlwZW9mIHN1YnMgPT09ICdvYmplY3QnICYmIHN1YnMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBpdG9waWMgPSBzdWJzW2ldLnRvcGljXG4gICAgICBjb25zdCBpcW9zID0gc3Vic1tpXS5xb3NcblxuICAgICAgaWYgKHR5cGVvZiBpdG9waWMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCB0b3BpYycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXFvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIHFvcycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICAgICAgY29uc3QgbmwgPSBzdWJzW2ldLm5sIHx8IGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YgbmwgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBObyBMb2NhbCcpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhcCA9IHN1YnNbaV0ucmFwIHx8IGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YgcmFwICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgUmV0YWluIGFzIFB1Ymxpc2hlZCcpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJoID0gc3Vic1tpXS5yaCB8fCAwXG4gICAgICAgIGlmICh0eXBlb2YgcmggIT09ICdudW1iZXInIHx8IHJoID4gMikge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBSZXRhaW4gSGFuZGxpbmcnKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoaXRvcGljKSArIDIgKyAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBoZWFkZXJcbiAgZGVidWcoJ3N1YnNjcmliZTogd3JpdGluZyB0byBzdHJlYW06ICVvJywgcHJvdG9jb2wuU1VCU0NSSUJFX0hFQURFUilcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlNVQlNDUklCRV9IRUFERVJbMV1bZHVwID8gMSA6IDBdWzBdKVxuXG4gIC8vIEdlbmVyYXRlIGxlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gR2VuZXJhdGUgbWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9PSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9IHRydWVcblxuICAvLyBHZW5lcmF0ZSBzdWJzXG4gIGZvciAoY29uc3Qgc3ViIG9mIHN1YnMpIHtcbiAgICBjb25zdCBqdG9waWMgPSBzdWIudG9waWNcbiAgICBjb25zdCBqcW9zID0gc3ViLnFvc1xuICAgIGNvbnN0IGpubCA9ICtzdWIubmxcbiAgICBjb25zdCBqcmFwID0gK3N1Yi5yYXBcbiAgICBjb25zdCBqcmggPSBzdWIucmhcbiAgICBsZXQgam9wdGlvbnNcblxuICAgIC8vIFdyaXRlIHRvcGljIHN0cmluZ1xuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwganRvcGljKVxuXG4gICAgLy8gb3B0aW9ucyBwcm9jZXNzXG4gICAgam9wdGlvbnMgPSBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19RT1NbanFvc11cbiAgICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgICAgam9wdGlvbnMgfD0gam5sID8gcHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfTkwgOiAwXG4gICAgICBqb3B0aW9ucyB8PSBqcmFwID8gcHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQIDogMFxuICAgICAgam9wdGlvbnMgfD0ganJoID8gcHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkhbanJoXSA6IDBcbiAgICB9XG4gICAgLy8gV3JpdGUgb3B0aW9uc1xuICAgIHJlc3VsdCA9IHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbam9wdGlvbnNdKSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gc3ViYWNrIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICBjb25zdCB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICBjb25zdCBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICBjb25zdCBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICBjb25zdCBncmFudGVkID0gc2V0dGluZ3MuZ3JhbnRlZFxuICBjb25zdCBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICBsZXQgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIENoZWNrIGdyYW50ZWQgcW9zIHZlY3RvclxuICBpZiAodHlwZW9mIGdyYW50ZWQgPT09ICdvYmplY3QnICYmIGdyYW50ZWQubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFudGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGdyYW50ZWRbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGVuZ3RoICs9IDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgbGV0IHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuU1VCQUNLX0hFQURFUilcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIHJldHVybiBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oZ3JhbnRlZCkpXG59XG5cbmZ1bmN0aW9uIHVuc3Vic2NyaWJlIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICBjb25zdCB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICBjb25zdCBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICBjb25zdCBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICBjb25zdCBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgY29uc3QgdW5zdWJzID0gc2V0dGluZ3MudW5zdWJzY3JpcHRpb25zXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG5cbiAgbGV0IGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCArPSAyXG4gIH1cbiAgLy8gQ2hlY2sgdW5zdWJzXG4gIGlmICh0eXBlb2YgdW5zdWJzID09PSAnb2JqZWN0JyAmJiB1bnN1YnMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnN1YnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgdW5zdWJzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgdW5zdWJzY3JpcHRpb25zJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVuc3Vic1tpXSkgKyAyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCB1bnN1YnNjcmlwdGlvbnMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGxldCBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlVOU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBVbnN1YnNcbiAgbGV0IHJlc3VsdCA9IHRydWVcbiAgZm9yIChsZXQgaiA9IDA7IGogPCB1bnN1YnMubGVuZ3RoOyBqKyspIHtcbiAgICByZXN1bHQgPSB3cml0ZVN0cmluZyhzdHJlYW0sIHVuc3Vic1tqXSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdW5zdWJhY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIGNvbnN0IHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIGNvbnN0IGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIGNvbnN0IGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICBjb25zdCBncmFudGVkID0gc2V0dGluZ3MuZ3JhbnRlZFxuICBjb25zdCBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICBjb25zdCB0eXBlID0gc2V0dGluZ3MuY21kXG4gIGNvbnN0IHFvcyA9IDBcblxuICBsZXQgbGVuZ3RoID0gMlxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBDaGVjayBncmFudGVkXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgaWYgKHR5cGVvZiBncmFudGVkID09PSAnb2JqZWN0JyAmJiBncmFudGVkLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFudGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JhbnRlZFtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ0ludmFsaWQgcW9zIHZlY3RvcicpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGxldCBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkFDS1NbdHlwZV1bcW9zXVtkdXBdWzBdKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9PSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG5cbiAgLy8gcGF5bG9hZFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShncmFudGVkKSlcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBlbXB0eVBhY2tldCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShwcm90b2NvbC5FTVBUWVtwYWNrZXQuY21kXSlcbn1cblxuZnVuY3Rpb24gZGlzY29ubmVjdCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgY29uc3QgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgY29uc3Qgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgY29uc3QgcmVhc29uQ29kZSA9IHNldHRpbmdzLnJlYXNvbkNvZGVcbiAgY29uc3QgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgbGV0IGxlbmd0aCA9IHZlcnNpb24gPT09IDUgPyAxIDogMFxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgbGV0IHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzLmRpc2Nvbm5lY3QgPDwgNF0pKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gcmVhc29uIGNvZGUgaW4gaGVhZGVyXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyZWFzb25Db2RlXSkpXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGF1dGggKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIGNvbnN0IHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIGNvbnN0IHJlYXNvbkNvZGUgPSBzZXR0aW5ncy5yZWFzb25Db2RlXG4gIGNvbnN0IHByb3BlcnRpZXMgPSBzZXR0aW5ncy5wcm9wZXJ0aWVzXG4gIGxldCBsZW5ndGggPSB2ZXJzaW9uID09PSA1ID8gMSA6IDBcblxuICBpZiAodmVyc2lvbiAhPT0gNSkgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKCdJbnZhbGlkIG1xdHQgdmVyc2lvbiBmb3IgYXV0aCBwYWNrZXQnKSlcblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGNvbnN0IHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzLmF1dGggPDwgNF0pKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gcmVhc29uIGNvZGUgaW4gaGVhZGVyXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmVhc29uQ29kZV0pKVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9PSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogd3JpdGVWYXJCeXRlSW50IC0gd3JpdGUgYW4gTVFUVCBzdHlsZSB2YXJpYWJsZSBieXRlIGludGVnZXIgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxOdW1iZXI+IGxlbmd0aCAtIGxlbmd0aCAoPjApXG4gKiBAcmV0dXJucyA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHZhckJ5dGVJbnRDYWNoZSA9IHt9XG5mdW5jdGlvbiB3cml0ZVZhckJ5dGVJbnQgKHN0cmVhbSwgbnVtKSB7XG4gIGlmIChudW0gPiBwcm90b2NvbC5WQVJCWVRFSU5UX01BWCkge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcihgSW52YWxpZCB2YXJpYWJsZSBieXRlIGludGVnZXI6ICR7bnVtfWApKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IGJ1ZmZlciA9IHZhckJ5dGVJbnRDYWNoZVtudW1dXG5cbiAgaWYgKCFidWZmZXIpIHtcbiAgICBidWZmZXIgPSBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQobnVtKVxuICAgIGlmIChudW0gPCAxNjM4NCkgdmFyQnl0ZUludENhY2hlW251bV0gPSBidWZmZXJcbiAgfVxuICBkZWJ1Zygnd3JpdGVWYXJCeXRlSW50OiB3cml0aW5nIHRvIHN0cmVhbTogJW8nLCBidWZmZXIpXG4gIHJldHVybiBzdHJlYW0ud3JpdGUoYnVmZmVyKVxufVxuXG4vKipcbiAqIHdyaXRlU3RyaW5nIC0gd3JpdGUgYSB1dGY4IHN0cmluZyB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPFN0cmluZz4gc3RyaW5nIC0gc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gd3JpdGVTdHJpbmcgKHN0cmVhbSwgc3RyaW5nKSB7XG4gIGNvbnN0IHN0cmxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cmluZylcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBzdHJsZW4pXG5cbiAgZGVidWcoJ3dyaXRlU3RyaW5nOiAlcycsIHN0cmluZylcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShzdHJpbmcsICd1dGY4Jylcbn1cblxuLyoqXG4gKiB3cml0ZVN0cmluZ1BhaXIgLSB3cml0ZSBhIHV0Zjggc3RyaW5nIHBhaXJzIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8U3RyaW5nPiBuYW1lIC0gc3RyaW5nIG5hbWUgdG8gd3JpdGVcbiAqIEBwYXJhbSA8U3RyaW5nPiB2YWx1ZSAtIHN0cmluZyB2YWx1ZSB0byB3cml0ZVxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1BhaXIgKHN0cmVhbSwgbmFtZSwgdmFsdWUpIHtcbiAgd3JpdGVTdHJpbmcoc3RyZWFtLCBuYW1lKVxuICB3cml0ZVN0cmluZyhzdHJlYW0sIHZhbHVlKVxufVxuXG4vKipcbiAqIHdyaXRlTnVtYmVyIC0gd3JpdGUgYSB0d28gYnl0ZSBudW1iZXIgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IG51bWJlciAtIG51bWJlciB0byB3cml0ZVxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cml0ZU51bWJlckNhY2hlZCAoc3RyZWFtLCBudW1iZXIpIHtcbiAgZGVidWcoJ3dyaXRlTnVtYmVyQ2FjaGVkOiBudW1iZXI6ICVkJywgbnVtYmVyKVxuICBkZWJ1Zygnd3JpdGVOdW1iZXJDYWNoZWQ6ICVvJywgbnVtQ2FjaGVbbnVtYmVyXSlcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShudW1DYWNoZVtudW1iZXJdKVxufVxuZnVuY3Rpb24gd3JpdGVOdW1iZXJHZW5lcmF0ZWQgKHN0cmVhbSwgbnVtYmVyKSB7XG4gIGNvbnN0IGdlbmVyYXRlZE51bWJlciA9IGdlbmVyYXRlTnVtYmVyKG51bWJlcilcbiAgZGVidWcoJ3dyaXRlTnVtYmVyR2VuZXJhdGVkOiAlbycsIGdlbmVyYXRlZE51bWJlcilcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZWROdW1iZXIpXG59XG5mdW5jdGlvbiB3cml0ZTRCeXRlTnVtYmVyIChzdHJlYW0sIG51bWJlcikge1xuICBjb25zdCBnZW5lcmF0ZWQ0Qnl0ZUJ1ZmZlciA9IGdlbmVyYXRlNEJ5dGVCdWZmZXIobnVtYmVyKVxuICBkZWJ1Zygnd3JpdGU0Qnl0ZU51bWJlcjogJW8nLCBnZW5lcmF0ZWQ0Qnl0ZUJ1ZmZlcilcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZWQ0Qnl0ZUJ1ZmZlcilcbn1cbi8qKlxuICogd3JpdGVTdHJpbmdPckJ1ZmZlciAtIHdyaXRlIGEgU3RyaW5nIG9yIEJ1ZmZlciB3aXRoIHRoZSBpdHMgbGVuZ3RoIHByZWZpeFxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IHRvV3JpdGUgLSBTdHJpbmcgb3IgQnVmZmVyXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nT3JCdWZmZXIgKHN0cmVhbSwgdG9Xcml0ZSkge1xuICBpZiAodHlwZW9mIHRvV3JpdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB0b1dyaXRlKVxuICB9IGVsc2UgaWYgKHRvV3JpdGUpIHtcbiAgICB3cml0ZU51bWJlcihzdHJlYW0sIHRvV3JpdGUubGVuZ3RoKVxuICAgIHN0cmVhbS53cml0ZSh0b1dyaXRlKVxuICB9IGVsc2Ugd3JpdGVOdW1iZXIoc3RyZWFtLCAwKVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzIChzdHJlYW0sIHByb3BlcnRpZXMpIHtcbiAgLyogY29ubmVjdCBwcm9wZXJ0aWVzICovXG4gIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ29iamVjdCcgfHwgcHJvcGVydGllcy5sZW5ndGggIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IDEsXG4gICAgICB3cml0ZSAoKSB7XG4gICAgICAgIHdyaXRlUHJvcGVydGllcyhzdHJlYW0sIHt9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcHJvcGVydGllc0xlbmd0aCA9IDBcbiAgZnVuY3Rpb24gZ2V0TGVuZ3RoUHJvcGVydHkgKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgdHlwZSA9IHByb3RvY29sLnByb3BlcnRpZXNUeXBlc1tuYW1lXVxuICAgIGxldCBsZW5ndGggPSAwXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdieXRlJzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtuYW1lfTogJHt2YWx1ZX1gKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDFcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2ludDgnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDB4ZmYpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtuYW1lfTogJHt2YWx1ZX1gKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDFcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkICR7bmFtZX06ICR7dmFsdWV9YCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSkgKyAyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdpbnQxNic6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMHhmZmZmKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkICR7bmFtZX06ICR7dmFsdWV9YCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyAyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdpbnQzMic6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMHhmZmZmZmZmZikge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcihgSW52YWxpZCAke25hbWV9OiAke3ZhbHVlfWApKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgNFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAndmFyJzoge1xuICAgICAgICAvLyB2YXIgYnl0ZSBpbnRlZ2VyIGlzIG1heCAyNCBiaXRzIHBhY2tlZCBpbiAzMiBiaXRzXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDB4MGZmZmZmZmYpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoYEludmFsaWQgJHtuYW1lfTogJHt2YWx1ZX1gKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIEJ1ZmZlci5ieXRlTGVuZ3RoKGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCh2YWx1ZSkpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkICR7bmFtZX06ICR7dmFsdWV9YCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyAyICsgQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUudG9TdHJpbmcoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3BhaXInOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkICR7bmFtZX06ICR7dmFsdWV9YCkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKHJlc3VsdCwgbmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlW25hbWVdXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJlbnRWYWx1ZS5yZWR1Y2UoKGN1cnJlbnRMZW5ndGgsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gMSArIDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChuYW1lLnRvU3RyaW5nKCkpICsgMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50TGVuZ3RoXG4gICAgICAgICAgICB9LCAwKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMSArIDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChuYW1lLnRvU3RyaW5nKCkpICsgMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlW25hbWVdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSwgMClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBJbnZhbGlkIHByb3BlcnR5ICR7bmFtZX06ICR7dmFsdWV9YCkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoXG4gIH1cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGxldCBwcm9wTGVuZ3RoID0gMFxuICAgICAgbGV0IHByb3BWYWx1ZUxlbmd0aCA9IDBcbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdXG4gICAgICBpZiAocHJvcFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IHZhbHVlSW5kZXggPSAwOyB2YWx1ZUluZGV4IDwgcHJvcFZhbHVlLmxlbmd0aDsgdmFsdWVJbmRleCsrKSB7XG4gICAgICAgICAgcHJvcFZhbHVlTGVuZ3RoID0gZ2V0TGVuZ3RoUHJvcGVydHkocHJvcE5hbWUsIHByb3BWYWx1ZVt2YWx1ZUluZGV4XSlcbiAgICAgICAgICBpZiAoIXByb3BWYWx1ZUxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIHByb3BMZW5ndGggKz0gcHJvcFZhbHVlTGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BWYWx1ZUxlbmd0aCA9IGdldExlbmd0aFByb3BlcnR5KHByb3BOYW1lLCBwcm9wVmFsdWUpXG4gICAgICAgIGlmICghcHJvcFZhbHVlTGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIHByb3BMZW5ndGggPSBwcm9wVmFsdWVMZW5ndGhcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcExlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICBwcm9wZXJ0aWVzTGVuZ3RoICs9IHByb3BMZW5ndGhcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJvcGVydGllc0xlbmd0aExlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGdlbkJ1ZlZhcmlhYmxlQnl0ZUludChwcm9wZXJ0aWVzTGVuZ3RoKSlcblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogcHJvcGVydGllc0xlbmd0aExlbmd0aCArIHByb3BlcnRpZXNMZW5ndGgsXG4gICAgd3JpdGUgKCkge1xuICAgICAgd3JpdGVQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcywgcHJvcGVydGllc0xlbmd0aClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUgKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKSB7XG4gIGNvbnN0IG1heUVtcHR5UHJvcHMgPSBbJ3JlYXNvblN0cmluZycsICd1c2VyUHJvcGVydGllcyddXG4gIGNvbnN0IG1heGltdW1QYWNrZXRTaXplID0gb3B0cyAmJiBvcHRzLnByb3BlcnRpZXMgJiYgb3B0cy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplID8gb3B0cy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplIDogMFxuXG4gIGxldCBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICBpZiAobWF4aW11bVBhY2tldFNpemUpIHtcbiAgICB3aGlsZSAobGVuZ3RoICsgcHJvcGVydGllc0RhdGEubGVuZ3RoID4gbWF4aW11bVBhY2tldFNpemUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRNYXlFbXB0eVByb3AgPSBtYXlFbXB0eVByb3BzLnNoaWZ0KClcbiAgICAgIGlmIChjdXJyZW50TWF5RW1wdHlQcm9wICYmIHByb3BlcnRpZXNbY3VycmVudE1heUVtcHR5UHJvcF0pIHtcbiAgICAgICAgZGVsZXRlIHByb3BlcnRpZXNbY3VycmVudE1heUVtcHR5UHJvcF1cbiAgICAgICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcGVydGllc0RhdGFcbn1cblxuZnVuY3Rpb24gd3JpdGVQcm9wZXJ0eSAoc3RyZWFtLCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHByb3RvY29sLnByb3BlcnRpZXNUeXBlc1twcm9wTmFtZV1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnl0ZSc6IHtcbiAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbK3ZhbHVlXSkpXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdpbnQ4Jzoge1xuICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFt2YWx1ZV0pKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHZhbHVlKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICB3cml0ZU51bWJlcihzdHJlYW0sIHZhbHVlKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnaW50MzInOiB7XG4gICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICB3cml0ZTRCeXRlTnVtYmVyKHN0cmVhbSwgdmFsdWUpXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICd2YXInOiB7XG4gICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCB2YWx1ZSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgdmFsdWUpXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdwYWlyJzoge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlW25hbWVdXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50VmFsdWUuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgICB3cml0ZVN0cmluZ1BhaXIoc3RyZWFtLCBuYW1lLnRvU3RyaW5nKCksIHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGVTdHJpbmdQYWlyKHN0cmVhbSwgbmFtZS50b1N0cmluZygpLCBjdXJyZW50VmFsdWUudG9TdHJpbmcoKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcihgSW52YWxpZCBwcm9wZXJ0eSAke3Byb3BOYW1lfSB2YWx1ZTogJHt2YWx1ZX1gKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVByb3BlcnRpZXMgKHN0cmVhbSwgcHJvcGVydGllcywgcHJvcGVydGllc0xlbmd0aCkge1xuICAvKiB3cml0ZSBwcm9wZXJ0aWVzIHRvIHN0cmVhbSAqL1xuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBwcm9wZXJ0aWVzTGVuZ3RoKVxuICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BlcnRpZXMsIHByb3BOYW1lKSAmJiBwcm9wZXJ0aWVzW3Byb3BOYW1lXSAhPSBudWxsKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgdmFsdWVJbmRleCA9IDA7IHZhbHVlSW5kZXggPCB2YWx1ZS5sZW5ndGg7IHZhbHVlSW5kZXgrKykge1xuICAgICAgICAgIHdyaXRlUHJvcGVydHkoc3RyZWFtLCBwcm9wTmFtZSwgdmFsdWVbdmFsdWVJbmRleF0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlUHJvcGVydHkoc3RyZWFtLCBwcm9wTmFtZSwgdmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmICghYnVmT3JTdHJpbmcpIHJldHVybiAwXG4gIGVsc2UgaWYgKGJ1Zk9yU3RyaW5nIGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gYnVmT3JTdHJpbmcubGVuZ3RoXG4gIGVsc2UgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJ1Zk9yU3RyaW5nKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ09yQnVmZmVyIChmaWVsZCkge1xuICByZXR1cm4gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyB8fCBmaWVsZCBpbnN0YW5jZW9mIEJ1ZmZlclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mqtt-packet/writeToStream.js\n");

/***/ })

};
;